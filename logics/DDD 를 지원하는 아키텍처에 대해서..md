
### 서론 : 아키텍처의 역할과 10년 후 인터뷰 비유

IDDD 4장 도입부에서는 **성공한 CIO와의 가상 인터뷰**를 통해, 한 스타트업(SaaSovation)이 **10년간 아키텍처적 결단으로 단계적 성공**을 거둔 이야기를 보여줌. 

>핵심 메시지는 : **옳은 아키텍처 선택이 실패 위험을 줄이고 성공을 견인한다**는 것처럼 보임.

>이 장 전체를 통해 강조되는 **논리**는, **도메인 모델**의 순수성을 지키면서도 다양한 기술적 요구에 대응하는 아키텍처를 취해야 한다는 것. 

>아키텍처 논의는 DDD의 **전략적 설계(큰 그림)** 와 **전술적 설계(구현 패턴)** 를 연결하는 다리 역할을 함. 

## 계층형 아키텍처 : 도메인 격리와 추상화에 기반한 논리적 구조
---

**계층(layered) 아키텍처**는 전통적으로 엔터프라이즈 애플리케이션에서 널리 사용되어 온 구조로, 시스템을 **수직적 계층**으로 나누어 각 계층이 책임을 분리하도록 함. 

에릭 에반스도 DDD에서 **계층 아키텍처**를 핵심 패턴으로 소개하며 다음과 같이 언급함.

> “도메인 모델과 비즈니스 로직을 표현하는 부분을 격리하고, 인프라 의존성이나 UI, 비즈니스 로직 이외의 애플리케이션 로직 등을 모두 제거하라. 복잡한 프로그램은 계층으로 나누어라. 각 계층은 응집성을 높이고 **바로 아래 계층**들에만 의존하도록 설계하라.”

위 지침을 **논리식**으로 표현하면 다음과 같음. 

시스템을 구성하는 모듈들을 집합 $L_{UI}, L_{App}, L_{Domain}, L_{Infra}$ (각각 사용자 인터페이스, 애플리케이션, 도메인, 인프라 계층)로 나눈다면

>[!NOTE]
>**정의 1 (계층 관계)**: 계층 간 의존은 부분 순서로서, $L_{UI} \to L_{App} \to L_{Domain} \to L_{Infra}$ 형태의 **단방향 관계**로 제한됨. 
  여기서 화살표 $A \to B$는 “계층 A가 계층 B에만 의존한다”를 의미.
  
  > [!NOTE]
  >**Layered Architecture 의 규칙** : _각 계층은 자기 자신의 내부와 바로 아래 계층에만 의존_. 
  >즉, 임의의 상위 계층 $X$는 하위 계층 $Y$에 대해서만 $X \to Y$ 관계를 가지며, 상위 계층 $X$는 $Y$의 아래 계층 $Z$에는 직접 의존하지 않는 것이 이상적 (이 원칙을 엄격 적용하면 **Strict Layered Architecture**, 완화하면 **Relaxed Layered Architecture**).

>[!IMPORTANT]
>이러한 계층화의 **논리적 전제**는 **분할 정복** 매커니즘으로 보여짐. 
>복잡한 문제를 논리적으로 분리하여 각 부분이 자체 **정합성**(consistency)을 갖게 함으로써, 전체 시스템의 복잡성을 줄임. 

예컨대, UI 계층은 화면 표현과 사용자 인터렉션에 집중하고, 도메인 계층은 순수 비즈니스 규칙에만 전념함. 

>[!NOTE]
>각 계층이 **자신의 관점에서 진리라고 보여지는 스탠스를 유지** 하고 다른 계층과는 **추상화된 계약**을 통해서만 상호작용하므로, 변경이 국지화됨. 
>UI 변경이 도메인 논리를 깨뜨리지 않고, 인프라 교체가 비즈니스 규칙을 훼손하지 않는 것.

>[!IMPORTANT]
>그렇기 때문에 특히나 중요한 **논리적 속성**은 **의존성 방향**이게 되는것. 

전통적 계층에서는 상위 계층 -> 하위 계층으로 의존성이 내려감. 

상위는 하위를 호출하고, 하위는 상위를 모름. 

이때 **문제 상황** : 만약 도메인 계층이 인프라 계층에 강하게 결합되어 있다면 (예: 도메인 객체가 DB SQL을 직접 호출), 인프라 변경이 도메인 규칙의 진리를 교란시킬 수 있음. 

**논리적 오류**가 발생하는 셈입니다. 

따라서 **의존성 역전 원칙**(DIP)이 등장하게 됨.

요약하면, 계층형 아키텍처는 **전제** : “시스템을 책임 영역별로 분리하면 변경 영향이 국소화되고 전체 안정성이 증가한다”는 설계 철학에 기반함. 

그리고 **결론**: “각 계층은 바로 아래 계층에만 의존하며, 상위-하위 간 느슨한 결합을 유지한다”는 규칙으로 구현됨. 

이 구조를 따르면 도메인 지식이 isolation 되므로, 도메인 모델이 **외부 기술 요소와 섞이지 않고 자체 논리를 보존**하게 됨. 

이질적인 공리계를 분리해 독립적인 이론으로 취급함으로써 **논리 간 간섭을 차단**하는 것과 유사.

### 의존성 역전 원칙(DIP)의 등장과 논리
---

**의존성 역전 원칙 (Dependency Inversion Principle)** 은 계층 구조에서 **의존성의 방향을 뒤집어** 결합도를 낮추는 핵심 원리. 

로버트 C. 마틴이 제안한 DIP의 공식 정의를 보면 다음과 같음.

- 상위 수준의 모듈은 하위 수준 모듈에 의존하면 안 된다. **둘 모두 추상화에 의존해야 한다**.
    
- 추상화는 세부 사항에 의존하면 안 된다. **세부 사항이 추상화에 의존해야 한다**.

이를 논리적으로 해석하면, 모듈 간 **의존 관계를 맺는 주체**를 구체 클래스(세부 구현)에서 **인터페이스나 추상 클래스(추상화)** 로 바꾸라는 뜻임. 

>[!Note]
>**전제** : 구체적인 세부 사항(데이터베이스, UI 프레임워크 등)은 자주 변하고 불안정하다. 
>**결론** : 변하기 쉬운 대상에 상위 정책(도메인 로직 등)이 직접 의존하고 있으면 상위의 논리도 불안정해지므로, 그 의존을 **안정적인 추상화**로 대체해야 한다. 

>[!IMPORTANT]
>다시 말해, **“변하는 것”** 이 **“변치 않는 것”** 을 바라보도록 **의존의 방향을 역전**시키는 것.

예를 들어, 전통 계층 구조에선 도메인 계층이 인프라(ORM, DB 등)를 호출하지만, DIP를 적용하면 **도메인 계층이 인터페이스**를 정의하고 **인프라 계층이 그 인터페이스를 구현**하도록 설계함. 

이렇게 하면 도메인->인프라 의존 대신, 인프라->도메인 방향의 의존이 생김 즉 의존성 방향이 역전됨. 

형식 논리로 표현하면 :

- **기존**: Domain ⇢ Infrastructure (`⇢`는 "의존한다" 의미)
    
- **DIP 적용**: Domain ⇠ Infrastructure, 단 **매개**로서 Domain이 정의한 추상 인터페이스 $I$를 경유. (Infrastructure ⇢ $I$, Domain ⇢ $I$, 그리고 실제 구현은 Infrastructure에서)
    
결과적으로 **도메인 모델이 인프라 세부사항을 모르게 되므로**, 도메인 논리는 오직 인터페이스 $I$에 대한 논리만 가지고, $I$의 구체 구현이 바뀌어도 자기 논리를 바꿀 필요가 없음. 

4장에서는 DIP를 설명하며 그 **본질**을 이렇게 요약함 

> “하위 수준의 서비스를 제공하는 컴포넌트(논의에선 인프라)가 **상위 수준 컴포넌트(논의에선 UI, 애플리케이션, 도메인)** 에서 정의한 인터페이스에 의존하도록 만든다.”

>이 말은, 예컨대 **도메인 계층이 `Repository` 인터페이스**를 정의하고, **인프라 계층이 `Repository` 구현체**를 제공하는 구조를 뜻함. 
>다시 말하면 도메인 코드는 “저장소에 저장한다”는 추상 개념만 알고, 실제 DB 저장 로직은 인프라에 위임.
 
![Image](https://github.com/user-attachments/assets/52bb434c-7ff6-4921-bc40-92b723dbd1aa)

본문 예시를 보면, DIP 구현부는 **기존 인프라 계층을 맨 위로 올려** 모든 아래 계층의 인터페이스를 구현하게 한 모습임.

이는 극단적으로 **인프라가 다른 계층들의 구현체 모음**처럼 동작함을 보여줌. 

“과연 DIP가 모든 계층에 일률적으로 적용되는 구조가 좋은가?” 

일부 사람들은 DIP를 딱 두 계층 간 규칙으로 이해하기도 함
(아래 계층에 인터페이스를 정의하고 위 계층이 그것을 구현). 

그러나 저자는 곧 **더 강력한 대안**으로 가이드 하는데 그게 바로 **헥사고날 아키텍처** 임

> [!Note]
> **정리하면**, DIP는 계층 구조의 **논리적 형태**를 재편함.
> 
> **전제**: 하위 세부 구현에 의존하면 상위 정책이 불안정해진다. 
> 
> **조치**: 추상 인터페이스를 도입해 의존 방향을 뒤집는다. 
> 
> **결론**: 상위와 하위 모두 추상화에 의존함으로써 (세부 -> 추상, 상위 -> 추상), 상위 정책의 안정성과 자율성을 확보한다. 
> 
> DIP를 적용하면, **도메인 모델이 기술 세부사항에 휘둘리지 않고 보존**됨.

마치 수학에서 보편 타당한 이론이 구체 모델의 변화에 영향받지 않듯이, 도메인 로직은 다양한 구현환경에서 **항진명제**처럼 유지될 수 있음.

>항진명제는 어떠한 경우에도 참이되는 명제를 말함. 
>즉, 명제 내의 명제 변수(P, Q, R 등)가 참이든 거짓이든 관계없이 항상 참인 명제. 
>예를 들어 "P ∨ ~P" (P 또는 ~P)와 같이 어떤 경우에도 참이 되는 명제는 항진명제라고 할 수 있다.

>[!IMPORTANT]
>흥미로운 점은, DIP를 극한까지 적용하면 **“계층이 실제로는 나뉘지 않은 것처럼”** 보이게 된다는 것. 
>상위와 하위 모두 추상화에 의존하므로 전통적인 **스택 계층 구조**가 논리적으로 붕괴되는 효과가 있음. 
>도메인과 인프라가 **동등한 수준에서 추상화**를 통해 연결될 뿐, 누구도 누구를 직접 참조하지 않기 때문. 
>
>이 상황을 한 단계 발전시켜 “소프트웨어 구조에 **대칭성**을 부여”하면? 
>**헥사고날 아키텍처**가 바로 그러한 **대칭적인 구조**를 제안함.

왜 대칭성으로 도달되는가

1. **동치 관계 정의**
    - A <-> I <-> B
        (상위 모듈 A, 하위 모듈 B가 **추상 I**만 의존)
        ∴ 의존 그래프에서 A, B 모두 I ‘평면’에 투영됨.
2. **평면 투영을 최소 차원으로 그리면** → **원형/다각형**
    - 방향 정보가 사라졌으므로, 방향성 없는 다각형이 최소.
3. **모든 외부 요소는 경계의 동등 점** (포트)
    - 어떤 면이 UI인지, DB인지, CLI인지 구분 불필요 → 추상화를 기반으로 **대칭** 적 구현
4. **모델링 경제성**
    - “계층” 개념을 버리면 **추상화·매핑 규칙이 한 세트**만 남아 규칙 수가 감소 → 설계·이해 비용 ↓.

만능은 아니다.
- 헥사고날로 “모든 문제 해결”은 아니다.
    - 동일 모듈 내 세밀한 층(예: 응용서비스 ↔ 도메인 모델)은 여전히 존재할 수 있다.
    - 팀이 레이어 용어에 익숙하면 **“계층 + DIP”** 로도 충분할 수 있다.
- **대칭 도식**은 **의사소통 모델**이다.
    - 문서·화이트보드에서 “코어-주변”을 쉽게 식별하도록 돕는 **시각적 약속**임.

### 헥사고날 아키텍처 : 대칭성과 포트 - 어댑터를 통한 중심 - 주변 분리
---

**헥사고날 아키텍처 (Hexagonal Architecture)**, 일명 **포트와 어댑터 아키텍처 (Ports & Adapters)**,은 Alistair Cockburn이 제안한 스타일로서, 소프트웨어 시스템에 **대칭성(symmetry)** 을 부여함. 

앞서 DIP로 암시된 바와 같이, 도메인을 시스템의 **중심**에 두고 그 주변을 둘러싼 여러 입력/출력 경로를 **동등한 환경**으로 보는 관점. 

헥사고날이란 이름은 육각형 모양의 다각형처럼 **다방향으로 포트가 열려 있음**을 비유한 것. 

각각의 변(면)이 하나의 포트(port)를 의미하고, 여기에 다양한 **어댑터(adapter)** 가 부착됨. 

헥사고날 아키텍처의 **논리 핵심**은 다음과 같이 요약할 수 있ㅇ.

- **포트(Port)** : 내부 **도메인 또는 애플리케이션 로직이 노출한 추상 인터페이스**. 
  포트는 도메인이 외부와 소통하는 창구로, 입력 포트 (예: 애플리케이션 서비스 인터페이스)와 출력 포트(예: Repository 인터페이스, 메시지 발행 인터페이스) 로 나뉨.
    
- **어댑터(Adapter)** : 외부의 구체 기술이나 구현을 포트에 **연결**하는 플러그인. 
  UI, DB, 파일시스템, REST API, 메시징 시스템 등 각각에 대해, **포트를 구현한 어댑터**가 존재. 
  예컨대 사용자 UI 어댑터는 사용자의 HTTP 요청을 받아 애플리케이션 서비스(입력 포트)를 호출하고, Repository 어댑터는 도메인이 정의한 Repository 인터페이스(출력 포트)를 구현하여 DB에 영속화 작업을 함.

이 스타일에서 **모든 종류의 클라이언트**(사용자, 외부 시스템, 테스트 코드 등)는 **동등한 지위**로 시스템과 상호작용합니다. 

즉, **새로운 클라이언트가 필요하면** 도메인 로직을 수정할 필요 없이 해당 클라이언트의 프로토콜을 받아들이는 어댑터만 추가하면 됨. 

반대로, **출력 측면**에서도 다양한 인프라 메커니즘(DB 종류 교체, 외부 서비스 교체 등)을 쉽게 바꿀 수 있음. 

애플리케이션에서 나온 결과를 그 기술이 요구하는 포맷으로 변환해주는 어댑터를 교체하면 되니까, 핵심 로직은 건드릴 필요가 없음. 

이러한 **개방-폐쇄적 구조** 덕분에, 헥사고날 아키텍처는 시간이 흘러도 **핵심 도메인 모델이 변경 없이 지속될 잠재력**을 지님. 

도메인 모델과 애플리케이션 로직은 외부 변화에 **불변의 중심**으로 남고, 새로운 요구 사항들은 주변 어댑터 층의 추가/교체로 대응하는 것.

논리적으로 표현하면, 헥사고날 아키텍처는 시스템을 **이원화**함 : 

**내부 세계** (도메인 모델 + 애플리케이션 서비스 = _불변의 이론_)와 **외부 세계** (UI, DB, 외부시스템 = _가변의 모델들_)로 구분함. 

그리고 DIP 원칙에 따라 내부는 추상 인터페이스(포트)만 외부로 노출하고, 외부는 그 인터페이스의 구현체(어댑터)로 응답함. 

내부 세계의 **언어와 진리**(유비쿼터스 언어, 비즈니스 규칙)는 외부로 **직접 새어나가지 않고** 포트를 통해 변환되므로, 논리적 **경계(boundary)** 가 생기는 셈. 
이 경계는 한편으로는 **완충지** 역할을 해서, 외부 환경 변화(예: UI 프레임워크 변경, DB 교체)가 내부 논리를 교란하지 않게 막아줌.

헥사고날 구조의 **대칭성**은, 입력과 출력 방향 모두 동일한 규칙이 적용된다는 뜻. 

전통 계층에서는 “위->아래” 단방향이었지만, 이제는 “안->밖/밖->안” 관계에서 **안쪽 도메인이 중심 축**이고, 바깥은 둘러싼 여러 면으로 대칭임. 

**모든 면이 평등**하므로, 테스트 환경도 하나의 면으로 취급됨. 

이 점이 **큰 이점**을 줌

**테스트를 위한 어댑터**를 쉽게 개발하여, 실제 UI나 DB가 없더라도 도메인 로직을 전부 가동하고 검증할 수 있음.

예를 들어, ProductService라는 애플리케이션 서비스 (입력 포트)를 호출하는 **테스트 클라이언트 어댑터**를 만들고, 영속성을 담당하는 Repository 출력 포트에는 간단한 **인메모리 구현 어댑터**를 붙여둔다고 한다면. 

그러면 웹 UI나 데이터베이스가 전혀 준비되지 않은 초기 단계부터도 **핵심 도메인 기능을 실행해서 테스트**해볼 수 있음. 

실제로 본문에서는 “HTTP/REST나 SOAP, 메시징 포트를 지원할지 결정하기 훨씬 전에 테스트를 생성해서 ProductService를 돌려볼 수 있다. UI 와이어프레임이 나오기 전에도 여러 테스트 클라이언트를 개발할 수 있다. DB 같은 영속성 메커니즘 결정까지 시간이 많이 남았어도, **인메모리 리포지토리를 써서 테스트할 수 있다**”라고 강조함. 

이는 **외부 의존이 없는 상태에서도 도메인 모델과 애플리케이션 로직의 진위를 검증**할 수 있음을 뜻함. 

결국, 헥사고날 아키텍처는 DIP의 논리를 극대화하여, **도메인 모델을 중심**에 **봉인**하고, 모든 입출력 경로를 추상화 경계로 분리한 구조. 

>[!Note]
>**전제**: 도메인 모델은 장기적으로 비즈니스 가치를 담는 불변핵(core)이므로, 외부 변화에 영향받아서는 안 된다. 
>**방법**: 모든 외부와의 연결을 추상화된 포트로 한정하고, 구체 구현은 어댑터들로 격리한다. 
>**결과**: 도메인 모델이 있는 내부 육각형은 변경 없이 오래 유지되고, 새로운 요구(클라이언트 유형 추가, 기술 변경 등)는 육각형의 변에 어댑터를 붙이거나 교체하는 것으로 대응한다. 

이러한 구조는 **장기적으로 아키텍처의 안정성**을 극대화 한다.

### 헥사고날 아키텍처의 확장: 시스템 경계와 서비스 지향
---

헥사고날 아키텍처 개념을 조금 확장하면, **서비스 지향 아키텍처(SOA)** 나 **마이크로서비스**와 자연스럽게 연결됨. 

DDD에서는 도메인 모델의 범위를 **바운디드 컨텍스트(Bounded Context)** 로 정의하는데, **하나의 바운디드 컨텍스트 = 하나의 헥사고날**로 볼 수 도 있음. 

즉, 컨텍스트마다 자체 육각형을 갖추고, 컨텍스트 경계는 곧 아키텍처 경계가 됨. 

**서비스 지향**이란 말 그대로 각 컨텍스트가 **독립 서비스**로 배포되거나, 기술적으로 독립된 모듈로 운영되는 것을 뜻함.

4장에서는 *“그림 4.5는 하나의 바운디드 컨텍스트 아키텍처를 보여주지만, 그 컨텍스트는 여러 RESTful 리소스, SOAP 인터페이스, 메시징 타입 등의 기술적 서비스 집합을 제공할 수 있다”*고 설명함. 

즉, 하나의 컨텍스트(예: 주문 컨텍스트)가 **REST API 엔드포인트 여러 개**, **SOAP 웹서비스**, **도메인 이벤트 메시지 스트림** 등 **여러 통신 채널**을 동시에 가질 수 있다는 뜻. 

이 모든 채널들이 모여 그 컨텍스트의 **“기술적 서비스”** 집합을 이루고, 이것이 비즈니스 기능의 한 단위를 외부에 제공함. 중요한 것은, DDD나 SOA 자체는 *“각 기술적 서비스 집합을 어떻게 설계/배포해야 하는지 명시하지 않는다”*는 점임. 

이미 다양한 선택지가 있기 때문에, 상황에 맞게 채널을 조합하면 됨. 

예컨대 어떤 컨텍스트는 REST API만 노출하고, 다른 컨텍스트는 메시지 기반으로 동작할 수도 있음.

**논리적 문제**는 _서비스 경계 결정이 도메인 모델 크기에 영향을 주는 경우_입니다. 본문은 “아키텍처가 도메인 모델의 크기에 영향을 주길 바라지 않는다”고 분명히 지적합니다. 이는 무슨 뜻일까요? 흔히 마이크로서비스 열풍 속에서 **기술적 서비스(예: 하나의 REST 리소스)**를 곧잘 **하나의 컨텍스트/모델**로 간주해버리는 실수가 발생합니다. 예를 들어, REST 리소스 하나 = 아주 작은 모델 하나로 쪼개다 보면, **컨텍스트 난립** 현상이 벌어집니다. *“REST 리소스나 SOAP 인터페이스 같은 기술적 서비스 엔드포인트 개수로 바운디드 컨텍스트의 크기를 정하려 하면, 매우 작은 컨텍스트와 도메인 모델이 양산되고, 각자 단 하나의 엔터티만 가진 미니 애그리게잇으로 전락할 수 있다”*고 경고합니다. 실제로 그렇게 되면 한 기업 내에 수많은 **미니어처 컨텍스트**들이 생겨버리고, 전체적으로 **모래알처럼 흩어진 모델**들만 남게 됩니다.

논리적으로 이는 **전제와 결론의 혼동**에 해당합니다. “서비스는 작게, 분리하라”는 기술적 전제를 맹목적으로 따르다 보면, **본래 지켜야 할 논리적 결합 (응집)**을 희생하게 됩니다. DDD의 전략적 설계 관점에서 **바운디드 컨텍스트는 충분한 도메인 의미와 응집도를 가진 경계**여야 합니다. 그런데 기술적 관점만으로 과도하게 쪼개면, 컨텍스트가 더 이상 의미있는 도메인 단위를 보장하지 못합니다. 각 조각은 자기 안에 거의 논리가 없고, 중요한 **개념적 불변식**도 컨텍스트 내부에 존재하지 않게 되죠. 이는 **전략적 DDD의 목표** (핵심 도메인을 식별하고 명확한 경계로 모델링하는 것)를 무색하게 만듭니다.

따라서, **주장**: 아키텍처는 도메인 모델을 표현하는 **단위와 경계**를 왜곡해서는 안 된다. **전제**: 좋은 도메인 모델은 특정 크기와 복잡도를 가져야 하며, 그 크기는 순전히 도메인 **개념 논리**에 의해 결정되어야 한다. **결론**: 기술적 구현상의 고려(엔드포인트 수 등)는 그 경계를 결정하는 요소가 되어선 안 된다.

이를 극단적으로 잘못하면 발생하는 현상을, 저자는 *“부정적인 평가를 받았던 SOA 선언문”*에 비유합니다. 과거 SOA에서는 서비스를 너무 기술적으로 쪼개 비판받은 역사가 있지만, 여전히 얻을 교훈이 있다고 합니다. 즉, **서비스 경계 = DDD 경계**를 잘 설정하면 SOA도 유익하다는 것이죠.

요약하면, **서비스 지향 DDD**에서는: **하나의 바운디드 컨텍스트 = 하나의 논리적으로 응집된 도메인 모델 = 하나의 서비스**로 매핑합니다. 그리고 그 서비스는 여러 기술 인터페이스(REST, SOAP, 메시징)를 가질 수 있습니다. 그러나 **절대 기술 인터페이스 하나당 컨텍스트 하나로 쪼개지 말라**는 겁니다. 논리학적으로 보면, “엔드포인트마다 모델을 만들라”는 전략은 _필요충분 조건을 혼동_한 오류라 할 수 있습니다. 실제로는 “모델이 서로 다르면 (bounded context가 다르면) 통신 엔드포인트가 나뉜다”가 참이지, 그 역은 일반적으로 거짓입니다. REST 리소스가 다르다고 반드시 별개 모델일 필요는 없으니까요. 이 **역불필요조건의 오류**를 경계해야 합니다.

결론적으로, 4장은 서비스지향 아키텍처에 DDD를 적용할 때 **논리적 균형**을 유지하라고 조언합니다. **아키텍처 스타일은 도메인 모델 크기에 영향줘서는 안 되며**, 오히려 **도메인 언어로 잘 정의된 모델**을 중심으로 그 주위에 적절한 기술 서비스들을 배치해야 합니다. 도메인 모델 경계가 기술에 종속되지 않도록 하는 것은 **논리적 필연성**입니다. 그렇지 않으면, 애그리게잇 하나짜리 자투리 모델들이 난립하고, 전체 진리를 논리적으로 조합해내기 어려운 **불완전한 지식 파편들**만 얻게 될 것입니다.

## RESTful 통신: 표현 상태 전달(REST)의 개념과 DDD의 만남

**REST (Representational State Transfer)**는 4장에서 강조된 아키텍처 스타일 중 하나로, 특히 웹 기반 통합에서 중요한 역할을 합니다. REST는 Roy Fielding의 웹 아키텍처 원리로부터 나온 개념으로, **자원(resource)** 지향, **표준 프로토콜(HTTP)** 활용, **상태 없는 통신(stateless)**, **캐시 가능성** 등의 특징을 가집니다. 4장은 REST를 DDD와 접목하여 논의하면서, RESTful한 설계가 가지는 장점들을 제시합니다.

REST의 기본 철학을 논리적으로 풀어보면, **서버는 자원의 상태를 여러 형태(representation)로 표현하여 클라이언트에게 전달**하고, **클라이언트는 표현을 조작하여 상태 전이를 유도**하는 구조입니다. 중요한 요소들을 살펴보겠습니다:

- **자원(Resource)**: 도메인 모델의 어떤 엔티티나 애그리게잇에 해당하는 **식별 가능한** 대상입니다 (예: `POST /orders`로 새로운 주문 생성, `GET /orders/{id}`로 주문 조회 등). DDD의 관점에서 **애그리게잇 루트**가 보통 하나의 리소스 엔드포인트로 매핑될 수 있습니다. 이는 DDD의 **유비쿼터스 언어**가 URL 등의 형태로 **노출**되는 것이기도 합니다.
    
- **표현(Representation)**: 리소스의 상태를 전달하는 구체 형식으로, JSON, XML, HTML 등이 해당합니다. DDD의 **발행된 언어(Published Language)** 패턴과 관련지을 수 있습니다. 발행된 언어란 컨텍스트 간 데이터 교환을 위한 합의된 언어인데, REST에서는 그 역할을 **미디어 타입과 리소스 표현**이 합니다. 예컨대, 주문 도메인의 개념을 JSON으로 직렬화한 스키마가 곧 발행된 언어가 될 수 있습니다.
    
- **HATEOAS(Hypermedia as the Engine of Application State)**: REST의 중요한 원칙으로, **하이퍼미디어 링크**를 통해 관련 자원 간 관계와 전이 가능 상태를 표현합니다. 예컨대 주문 조회 결과에 “취소” 링크를 포함하면, 클라이언트는 그 링크를 따라 주문 취소를 수행할 수 있습니다. 이는 **애플리케이션 상태 전이를 하이퍼미디어로 구동**하는 것으로, 클라이언트가 사전에 모든 URI를 알 필요 없이 동적으로 탐색하게 합니다. 논리적으로, **도메인 모델의 관계**를 **그래프** 형태로 노출하여 클라이언트 측 **탐색가능 논리**를 제공하는 셈입니다. 이때 각 링크에 의미 있는 관계 이름을 부여하므로, **유비쿼터스 언어**의 일부가 하이퍼링크 rel로 표현되기도 합니다.
    
- **Self-descriptiveness 및 Content Negotiation**: RESTful 시스템은 메시지 자체에 충분한 정보를 담아야 하며(self-descriptive), 클라이언트는 원하는 표현 형식을 **Content-Type / Accept 헤더**로 협상할 수 있습니다. 4장에선 “각 클라이언트가 선호하는 언어(포맷)를 지정하면, 리소스가 그 요청 콘텐츠 타입에 맞춰 표현을 렌더링한다”는 REST의 이점을 소개합니다. 예컨대 어떤 클라이언트는 XML을 원하고 다른 하나는 JSON을 원해도, 서버는 둘 다 지원 가능하면 각각 제공할 수 있죠. 이는 **동일한 도메인 정보가 표현만 달리하여 전달**될 뿐 본질적 의미는 유지됨을 뜻합니다. 논리적으론, 하나의 **추상적 진술** $P$ (예: “주문 #123의 상태는 SHIPPED”)가 XML($P_{xml}$)과 JSON($P_{json}$) **동등한 문장**으로 표현되는 것입니다.
    

4장에서 REST의 장점으로 특히 강조된 것은, **REST가 DDD의 일부 패턴을 자연스럽게 구현할 수 있다**는 점입니다. 예를 들어 **오픈 호스트 서비스(Open Host Service)**는 바운디드 컨텍스트가 외부에 기능을 개방하는 패턴인데, 이것을 RESTful 리소스로 구현하면 된다고 합니다. 많은 사람이 OHS를 SOAP/RPC처럼 생각하지만, RESTful하게 자원-행위 API를 설계하는 것이 현대적이고 단순한 대안이라는 것이지요. 또 **발행된 언어(Published Language)** 역시 REST API의 표준 포맷(JSON Schema 등)으로 전달되는 자원 표현으로 나타낼 수 있다고 설명합니다. 이러한 REST 기반의 통합은 **HTTP라는 오픈 표준** 위에서 이루어지므로, **클라이언트/서버의 기술 스택에 독립적인 상호운용성**을 보장합니다. 가령, 주문 컨텍스트를 Java로 구현해 REST API로 열어두면, Python, JavaScript, Ruby 등 어떤 언어로 작성된 클라이언트라도 HTTP만 이해하면 접근할 수 있습니다. **논리적 상호운용**이 달성되는 셈입니다.

**REST와 DDD의 접점**은, **자원을 도메인 개념으로 식별**하고, **HTTP 동사를 통해 의도를 표현**하며, **URI 구조를 통해 도메인 관계를 반영**하는 데서 찾을 수 있습니다. 좋은 RESTful 설계는 _“리소스 URL과 요청 형태만 보아도 어떤 도메인 동작인지”_ 이해가 갈 정도로 자명해야 합니다. 이는 결국 DDD의 **유비쿼터스 언어(Ubiquitous Language)**를 HTTP 인터페이스로 그대로 드러내는 것이기도 합니다. 예컨대 `POST /orders/{id}/cancel` 같은 endpoint는 Order 애그리게잇의 취소 명령을 실행하는 명시적 표현이며, 이 **명령 모델** 개념이 곧바로 REST에 투영된 것입니다.

4장 “왜 REST인가” 부분에서는 이러한 점들을 정리하며, REST가 **경량**이고 **웹 친화적**이며 **클라이언트에 유연성 제공** 등의 이유로 오늘날 선호된다고 언급했을 것입니다. **논리적 요약**: REST는 *“HTTP 표준과 웹 철학에 부합하여 상호운용성과 확장성을 극대화하는, 낮은 결합도의 서비스 통합 스타일”*입니다. 클라이언트-서버 간 **계약**이 URI 템플릿과 미디어 타입 형식으로 비교적 안정적으로 정의되므로, 도메인 모델을 바꾸지 않는 한 인터페이스도 일관되게 유지됩니다. 그리고 만약 변경이 필요하면 새로운 URI나 버전으로 추가 노출하면 되니, 기존 클라이언트와의 **논리적 하위 호환성**도 유지 가능합니다. 이러한 면에서 REST는 “세월이 흘러도 도메인 모델만 단단하다면 API도 큰 변화 없이 견디는” 특성을 보입니다.

마지막으로, REST의 **Hypermedia** 원칙(HATEOAS)을 DDD와 연결지어 생각해 보면 재미있는 논리가 나옵니다. **하이퍼미디어 링크**들은 마치 **논리적인 추론 규칙**처럼 작동합니다. 클라이언트는 현재 리소스 표현에 담긴 링크들을 해석함으로써, *지금 이 상태에서 내가 취할 수 있는 행위는 무엇인가?*를 알아냅니다. 이는 _어떤 조건 하에서 어떤 행위가 가능한지_를 제시하는 것으로, 일종의 **규칙기반 시스템**과 유사합니다. 예를 들어 주문 상태가 “SHIPPED”인 경우에만 “deliver” 링크가 존재한다면, 클라이언트는 **“주문이 발송된 경우에만 배송 완료 처리를 할 수 있다”**는 규칙을 하이퍼미디어를 통해 인지합니다. 이러한 REST API는 도메인 규칙을 클라이언트에게 **논리적 제약** 형태로 알리는 효과가 있습니다. 결국 RESTful 시스템에서는, 서버와 클라이언트가 **공유하는 논리**를 HTTP와 hypermedia로 전달하며, 이는 DDD의 풍부한 도메인 지식을 클라이언트 생태계까지 전파하는 세련된 방식이라 할 수 있습니다.

## 명령-쿼리 책임 분리(CQRS): 두 모델로 나눈 논리적 역할

이제 4장은 보다 **고급 패턴**으로 나아갑니다. **CQRS (Command-Query Responsibility Segregation)**, 우리말로 **명령-쿼리 책임 분리**는, **읽기와 쓰기의 책임을 분리한 이중화된 모델 전략**입니다. 전통적인 도메인 모델(한 클래스가 명령 메소드와 조회 메소드를 모두 가짐)과 대비되는 개념으로, Bertrand Meyer의 CQS 원칙(함수는 오직 명령 또는 조회만 해라)을 시스템 수준으로 확장했다고 볼 수 있습니다.

CQRS의 아이디어를 논리적으로 전개해 보겠습니다:

- **전제 상황**: 하나의 객체(또는 한 모델)이 상태를 변경하는 **명령 작업(command)**과 상태를 반환하는 **조회 작업(query)**을 모두 제공하고 있다. 이 경우 **트레이드오프**가 생깁니다. 객체 내부 설계를 명령 위주로 최적화하면 조회 성능이나 표현이 불편해지고, 조회를 편하게 하자니 캡슐화가 깨지거나 불변 조건 유지가 어려워질 수 있습니다.
    
- **핵심 원칙**: _“어떤 모델은 변경을 처리하고, 다른 모델은 조회를 처리하게 하자.”_ 다시 말해, **쓰기 모델(Write Model)**과 **읽기 모델(Read Model)**을 분리합니다. 여기서 쓰기 모델은 오로지 비즈니스 행동(명령)을 수행하며, 읽기 모델은 사용자 화면이나 리포트 등에 최적화된 조회만 담당합니다.
    

4장은 이를 구현 차원에서 상세히 묘사합니다: _“애그리게잇은 getter 같은 조회 메소드를 하나도 포함하지 않고 오직 커맨드 메소드만 갖게 된다. 리포지토리도 fromId 정도의 단일 조회 메소드 외에는 add/save 등 쓰기용 메소드만 제공한다.”_ 그 결과, 전통 모델에서 조회를 위한 복잡한 메소드들 (예: 조건 검색 등)은 모두 제거되고, **이 순수한 명령 모델**이 남습니다. 대신 *“사용자에게 데이터를 보여줄 방법이 여전히 필요하므로, 최적화된 쿼리에 맞춘 두 번째 모델을 생성하는데, 이를 쿼리 모델이라고 한다”*고 설명합니다. 이 쿼리 모델은 주로 데이터베이스 View나 별도 읽기 전용 테이블, 캐시 테이블 형태로 구현하며, 여러 애그리게잇의 데이터를 **비즈니스 무결성 제약 없이** 통합해 갖고 있을 수도 있습니다 (오직 조회만 하니까 허용되는 denormalization).

**논리적 효과**: 한 개념을 표현하던 모델을 둘로 쪼갬으로써, 각 모델이 **단일 책임**을 가지게 됩니다. **명령 모델**은 강한 불변 조건과 비즈니스 규칙을 지키며 상태를 변경하는 데 집중합니다. 명령 모델 객체는 자기 상태를 외부에 거의 노출하지 않으므로(조회 기능이 없으므로), **부수효과**나 **캡슐화 위반** 우려 없이 **자기 일관성**을 유지합니다. **조회 모델**은 말 그대로 데이터를 빠르게 조회하고 가공된 형태로 제공하는 데만 집중하므로, 효율적인 SQL이나 캐시 구조, 인덱싱 등을 마음껏 활용할 수 있습니다. 심지어 조회 모델은 RDB가 아니라 NoSQL, 전문 검색엔진(엘라스틱서치 등) 등으로 구현할 수도 있죠. 이런 유연성은 **논리적으로** “읽기에는 완전히 별도의 최적화를 적용”할 수 있게 함을 의미합니다.

**Premise-Conclusion 관점**으로 CQRS를 보면:

- **Premise**: 하나의 모델로 읽기/쓰기를 모두 처리하면 설계 상 복잡성과 상충(양립할 수 없는 최적화 요구)이 생긴다.
    
- **Strategy**: 모델을 두 개로 분리하여, 쓰기 모델은 비즈니스 로직(상태 변경) 전담, 읽기 모델은 데이터 표시/질의 전담으로 만든다.
    
- **Conclusion**: 결과적으로 시스템 전체의 복잡성을 한곳에 몰아넣지 않고 분산시켜 관리 가능하게 한다. _“전통적인 도메인 모델이 둘로 분리된다”_ – 하나는 커맨드 모델, 다른 하나는 쿼리 모델.
    

하지만 이런 접근은 새로운 **과제**를 낳습니다. 4장도 이 점을 지적합니다: *“너무 많은 일을 벌이는 것 아닌가? 한 문제를 다른 문제로 대체하면서 코드만 늘어나는 것은 아닌가?”*라는 의구심이 들 수 있다는 것입니다. 다시 말해 **돌발적 복잡성(Accidental Complexity)** 증가 우려죠. 저자는 이에 대해 _“너무 성급히 포기하지 말라. 어떤 상황에서는 추가 복잡성이 정당화될 수 있다. CQRS는 복잡한 문제의 특정 뷰(view)를 해결하기 위한 것이지, 그저 이력서를 빛내줄 멋진 스타일 만지작거리기가 아니다”_ 라고 단호히 말합니다. 요컨대, **CQRS는 남발해서는 안 되고, 필요할 때 써야 하는 도구**라는 것이죠. **논리적 해석**: CQRS 적용의 **전제 조건**은 “시스템이 복잡해서 이러한 분리가 없으면 오히려 더 큰 혼란이 생긴다”는 충분한 이유가 있어야 한다는 것입니다. 그 “복잡한 문제의 특정 뷰”란 예컨대 **읽기 트래픽이 압도적으로 높은 상황**이라든가, **도메인 모델이 지나치게 많은 조회 요구로 비대해진 경우** 등을 말합니다. 그러한 경우에만, **추가적인 개념적 분기** (두 모델로 나누는 것)가 정당화됩니다.

CQRS를 실제 운영하면, **최종적 일관성(Eventual Consistency)** 이슈가 자연스럽게 따라옵니다. 왜냐하면 명령 모델과 쿼리 모델이 물리적으로 분리되었으므로, 쓰기 모델에서 데이터 변경이 발생했을 때 읽기 모델이 **곧바로 즉시** 똑같이 업데이트된다는 보장이 없기 때문입니다. 일반적으로는 **이벤트**나 **비동기 동기화 프로세스**를 통해 읽기 모델을 갱신하는데, 이때 약간의 지연 시간이 발생할 수 있습니다. 다음 절에서 이 **결과적 일관성** 상황을 다룰 것입니다. 그러나 그 전에, CQRS와 앞서 소개된 패턴들의 관계를 정리해 보면:

- CQRS의 구현은 **DIP**/헥사고날과 상충되지 않습니다. 오히려, **DIP를 적용한 Repository 인터페이스**가 CQRS 상황에선 자연스럽게 두 종류로 분화합니다. 명령 모델의 Repository (fromId로 Aggregate 불러오고, 저장하는 기능만)와 조회 모델의 Repository (다양한 조회 쿼리로 이루어진 DAO와 유사한 것)로 나뉠 수 있습니다.
    
- **REST API** 관점에서 보면, 명령 모델은 보통 HTTP POST/PUT 등 **동작을 유발**하는 엔드포인트들로 매핑되고, 조회 모델은 HTTP GET으로 **데이터를 제공**하는 엔드포인트들로 매핑됩니다. 클라이언트는 GET으로 읽을 데이터와 POST/PUT으로 보낼 명령의 대상이 서로 다를 수도 있습니다. (예: 주문 쓰기모델은 내부 DB이고, 읽기는 ElasticSearch를 조회)
    
- **이벤트 주도 아키텍처(EDA)**와도 관련 깊습니다. 왜냐하면, 명령 모델에서 무언가 변경되면 **도메인 이벤트**를 발행하여 읽기 모델이 이를 수신, 갱신하는 방식이 일반적입니다. 따라서 CQRS를 고려하면 **도메인 이벤트 설계가 필수적**이 되고, EDA와 CQRS가 결합됩니다. 4장에서도 *“CQRS의 일부 컴포넌트들은 다른 이름으로도 알려져 있다... 내가 쿼리 모델이라 부른 것은 읽기 모델로도 알려져 있고, 커맨드 모델은 쓰기 모델로도 불린다”*라며 개념 정리를 한 뒤, *“결과적으로 전통적 도메인 모델이 둘로 분리된다”*고 설명했습니다. 이 흐름에서 **도메인 이벤트**는 쓰기 모델 -> 읽기 모델로 **정보를 전달하는 매개체**가 됩니다. 이는 다음 절에서 구체화됩니다.
    

## 결국은 일관성이 유지되는 쿼리 모델: **최종적 일관성**과 사용자 경험

CQRS와 함께 따라오는 주제는 **“결국은 일관성이 유지되는(eventually consistent)”** 시스템을 어떻게 다룰 것인가입니다. 쓰기-읽기 모델 분리로 인해, **데이터 일관성**은 즉각적(strong consistency)이 아니라 잠정적(eventual consistency)이 됩니다. 이는 **분산 시스템의 CAP 이론** 중 _일관성과 가용성의 트레이드오프_에 해당하는 현실적인 타협이기도 합니다. 4장은 이 상황에서 **사용자 경험(UX)**과 **설계 전략**을 논의합니다.

**시나리오**: 사용자 A가 어떤 명령(예: “주문 상태를 배송 완료로 변경”)을 수행했습니다. 이 명령은 **쓰기 모델**에 적용되어 성공적으로 커밋되었습니다. 곧바로 사용자 A의 화면(혹은 다른 사용자 B의 화면)에서 **읽기 모델 기반 데이터**를 새로 고침 하면, 방금 변경한 상태가 반영될까요? **불확실**합니다. 이상적으로는 곧 반영되지만, 시스템 부하나 네트워크 지연 등에 따라 몇 초 혹은 그 이상 지연될 수도 있습니다. **최악의 경우**를 가정해 보라는 것이 4장의 조언입니다: _“UI가 절대 일관성을 유지하지 못하는 최악의 상황을 고려해 설계하라”_. 즉, 사용자에게 **일시적으로 틀린 정보(구 데이터)**가 보일 가능성을 전제로 디자인을 짜야 한다는 것입니다.

**논리적 문제**: 명령 직후 읽기 결과가 일치하지 않을 수 있다 = 시스템 상태에 대해 **시점에 따라 참/거짓 평가가 달라지는** 상황이 발생. 이것은 논리적으로 **일시적 모순**처럼 보일 수 있습니다. 하지만 “eventually consistent”라는 말이 보여주듯, **시간 $t$가 충분히 흐르면** 모순은 해소되고 일관성이 회복된다는 전제가 있습니다. 그러므로 이 기간 동안의 모순을 **사용자가 인지하지 못하게** 하거나, **인지하더라도 수용**할 수 있게 만드는 것이 중요합니다.

4장에서는 하나의 **UX 패턴**을 제안합니다: *“방금 실행된 명령의 매개변수로서 성공적으로 보낸 데이터를 일시적으로 UI에 표시”*하라는 것입니다. 쉽게 말해, 사용자가 제출한 변경사항을 **UI 쪽에서 미리 적용해 보여주는** 것입니다. 예를 들어 사용자가 주문을 “배송 완료” 처리했으면, 비록 쿼리 모델 DB에 반영되기 전이지만 **UI 리스트에서 해당 주문의 상태를 곧바로 ‘배송 완료’로 바꿔** 보여줍니다. 이것은 엄밀히 따지면 현재 읽기 모델의 실제 값이 아닐 수도 있지만, 사용자가 기대하는 **미래의 일관된 상태를 미리 시뮬레이션**해주는 것입니다. 저자는 이를 “일종의 속임수긴 하지만, 사용자가 최종적으로 쿼리 모델에 반영될 내용을 즉시 확인할 수 있게 해준다”라고 표현했습니다. 이 방법은 **적어도 방금 액션을 한 당사자에게는** 시스템이 **즉각 반응**한 것처럼 보이게 하여, UI가 명령 직후 **옛 데이터(old data)**를 보여주는 문제를 피할 수 있게 합니다.

물론 이 방식은 *“만약 명령 실패나 롤백이 있다면 UI와 실제 데이터 간 부조화가 생길 수 있다”*는 리스크가 있습니다. 따라서 실제 구현에서는, 명령이 완전히 성공했다고 확인된 후에야 UI에 적용하거나, 실패 시는 다시 되돌리는 등의 추가 논리가 필요합니다. 하지만 개념적으로, **UI단에서 명령의 효과를 미리 적용**하는 것은 **임시 일관성 격차**를 메우는 한 가지 논리적 해법입니다. 이는 **낙관적 업데이트(optimistic UI)**라고도 부르며, 사용자 경험 측면에서 응답성을 높여주지만, 내부적으로 **사후 검증**(추후 쿼리 모델 sync) 절차를 동반합니다.

4장은 이 외에도, **궁극적으로도 일치하지 않을 수 있는 시나리오**도 언급합니다. 예컨대 사용자 A와 B가 서로 다른 UI에서 같은 데이터를 보고 있고, A가 변경한 직후 B는 아직 옛 데이터를 볼 수 있습니다. B의 화면은 시간이 지나 동기화되겠지만, 그 **사이 간격** 동안 시스템은 두 사람에게 **다른 진실**을 보여주는 격이죠. 이런 경우 완전히 해결책이 없을 수도 있습니다. 따라서 설계자는 사용자들에게 **“데이터가 실시간으로 동기화되지 않을 수 있다”**는 것을 암묵적으로 이해시키거나, 중요하면 **알림(notification)** 등을 활용해 새 데이터 도착을 알려줄 수 있습니다.

정리하면, **최종적 일관성 상황에서의 논리적 도전**은: 동일한 논리 명제 $P$ (예: “주문 #123은 배송 완료 상태다”)에 대해, 시간 T0에는 거짓이었다가 T1에는 참이 되는 변화가 생기며, _일시적으로 어떤 관찰자에게는 참, 다른 관찰자에게는 거짓_으로 보일 수 있다는 점입니다. 이건 시제 논리(temporal logic)로 보면 모순이 아닙니다 – $P$가 항상 참인 건 아니고, 결국 참이 되는 (◇□P) 정도로 표현될 수 있습니다. 그러나 사용자 입장에선 헷갈릴 수 있죠. 그래서 UI/UX에서는 **시간이라는 차원을 인지**하고, *“이 데이터는 업데이트 중”*과 같은 신호를 주거나, 아예 앞서 말한 것처럼 **낙관적 UI**로 사용자 동작을 즉각 반영하는 것이 좋습니다.

4장의 권고는 **최악의 상황을 기준으로 설계하라**는 것이었습니다. 즉, “아마 곧 동기화될 거야”라고 낙관하지 말고, *“당장은 안 맞을 수도 있다”*를 기본 가정으로 UX를 만들라는 것입니다. 이는 논리적으로 **안전한 설계**입니다. 최악을 가정하면 논리적 모순을 다룰 여지가 줄어들고, 실제로 운 좋게 빨리 동기화되면 문제 없으니까요. 예를 들어, 은행 어플리케이션에서 이체를 완료한 후 잔액이 즉시 안 맞게 나올 수 있다는 것을 사용자에게 “곧 반영됩니다” 배지로 알리는 식입니다.

결론적으로, **CQRS로 인해 발생하는 최종적 일관성 문제**는 기술적으론 **eventual consistency**라 부르고, 이것을 **사용자 경험 논리**와 **프로세스 논리**로 다뤄야 합니다. **UI 논리** 측면에서는 낙관적 업데이트나 업데이트 지표를 사용하며, **프로세스 논리** 측면에서는 시스템이 일정 주기로 새 상태를 푸시하거나, 사용자가 페이지를 리프레시할 수 있게 하는 식으로 합니다. 4장 예시의 “데이터를 임시로 UI에 보여주기”는 UI 논리 방안 중 하나였던 것입니다.

요컨대, **“일관성 지연”**을 **“사용자 불일치 인지 지연”**으로 치환하는 것이 핵심 아이디어입니다. 논리적 모순을 일시적으로 감추고, 결국 참값이 확정되면 그것을 사용자에게 인식시키는 것이죠. 이로써 시스템은 최종적으로 **일관된 논리 상태**로 수렴하며, 사용자도 큰 불편 없이 이를 받아들이게 됩니다.

## 이벤트 주도 아키텍처(EDA): 발행-구독을 통한 느슨한 연결

**이벤트 주도 아키텍처 (Event-Driven Architecture)**는 4장의 후반부에서 다루는 주요 개념입니다. EDA는 시스템이 **이벤트**라는 메시지를 중심으로 동작하는 아키텍처 스타일로, 구성 요소들이 **발행/구독(pub-sub)** 모델로 상호작용합니다. DDD와 EDA의 결합은 **도메인 이벤트** 개념을 통해 이루어지며, 이 역시 **논리적 구조와 장단점**을 지니고 있습니다.

EDA의 기본 원리는 간단합니다: 한 컴포넌트에서 **유의미한 사건(event)**이 발생하면, 이를 **이벤트 메시지**로 만들어 **발행(publish)**합니다. 관심 있는 다른 컴포넌트들은 그 **이벤트를 구독(subscribe)**하고 있다가, 이벤트를 받으면 **자신의 로직을 실행**합니다. 이때 발행자는 수신자를 몰라도 되고, 수신자는 발행자 내부를 몰라도 됩니다. **논리적으로** 이는 관찰자 패턴(Observer Pattern)의 시스템 버전이라고 할 수 있습니다. 어떤 **명제 $E$ (“이런 사건이 발생했다”)**가 참이면, 이를 가정(premise)으로 삼아 별도의 추론(handling 로직)이 여러 곳에서 이루어지는 식입니다. 발행자는 $E$의 발생만 알리고 자신의 일은 끝내며, 이후의 처리는 각각의 리스너(구독자)가 자신의 **전제부** 조건에 $E$를 넣고 **추론**을 전개하는 꼴입니다.

DDD에서는 **도메인 이벤트**라는 개념이 있습니다. 도메인 이벤트는 *“도메인 모델 내에서 일어난 과거의 사건”*을 객체로 표현한 것입니다. 예를 들어 “주문이 취소됨(OrderCanceled)”이나 “재고 부족 발생(StockShortageDetected)” 등이 될 수 있죠. DDD 전술 패턴 중 도메인 이벤트를 발행하면, 같은 바운디드 컨텍스트 내의 다른 부분이나 완전히 다른 컨텍스트가 그 이벤트를 받을 수 있습니다. 4장은 특히 **다중 시스템 환경**에서 EDA를 설명합니다. *“몇몇 시스템이 전반적으로 헥사고날 스타일을 따르며 이벤트 주도 아키텍처를 사용하고 있다”*는 그림 4.7 예시에서, 3개의 시스템(컨텍스트)이 메시징 인프라로 서로 이벤트를 교환하는 모습이 그려집니다.

EDA의 **가장 큰 장점**은 **컴포넌트 간 결합도를 극도로 낮출 수 있다는 것**입니다. 서로 **직접 호출**(동기 호출)하지 않고, 이벤트 버스를 통해 **비동기 통신**하므로, 한쪽이 다운되거나 느려도 다른 한쪽은 일단 자기 일(이벤트 발행)은 끝내고 다음으로 진행할 수 있습니다. 또한 새로운 구독자를 얼마든지 추가할 수 있어 **확장성**도 높습니다. 예컨대 주문 컨텍스트가 “OrderPlaced” 이벤트를 발행하도록 만들어두면, 초기에 없던 “추천 엔진” 컨텍스트가 생겨 이 이벤트를 구독하고 “주문 기반 추천” 기능을 나중에 추가해도, 기존 시스템을 거의 손대지 않고도 통합할 수 있습니다. **논리적 의미**: $A$ 시스템에서 $E$라는 사실을 발표하면, 그 사실을 필요로 하는 임의의 $B, C, ...$ 시스템들이 나중에라도 등장해 이유식을 먹을 수 있다는 겁니다. $A$는 $B, C$의 존재를 몰라도 ${E}$라는 **공용 논리 사실**로 간접 대화가 가능한 것이죠.

4장은 이 구조를 두고, *“EDA 스타일은 시스템의 메시징 메커니즘 자체 의존성과 구독하는 이벤트 타입 외의 모든 것을 분리시켜준다”*고 정리합니다. 즉, 각 시스템은 메시징 채널(예: JMS, Kafka 등)과 **이벤트 정의(타입)**만 맞추면 되고, 서로의 내부 구현, DB 구조 등을 몰라도 된다는 뜻입니다. 또한 *“한 시스템의 출력 포트를 통해 게시된 도메인 이벤트는 다른 시스템의 입력 포트를 통해 해당 컨텍스트의 구독자에게 전달된다”*고 설명합니다. 이는 헥사고날 개념과 연결되는데, **출력 어댑터**가 이벤트 버스에 이벤트를 게시하고, **다른 컨텍스트의 입력 어댑터**가 그 이벤트를 받아 도메인 로직을 호출하는 그림입니다. 여러 시스템이 모두 헥사고날 구조라면, 각자의 **이벤트 발행 포트**와 **이벤트 수신 포트**를 통해 이벤트가 흘러다니는 것입니다.

EDA의 **논리적 효과**는, 시스템들 간의 의존 관계를 **사건 중심의 논리적 인과관계**로 바꾼 것입니다. 예를 들어, “결제 시스템이 주문 시스템 API를 호출하여 배송을 지시”하는 직접 호출 구조 대신, “결제 시스템이 ‘결제완료’ 이벤트를 발행하면 주문 시스템이 이를 구독하여 배송 프로세스를 시작”하는 식으로 전환됩니다. 전자의 동기 호출 모델에서는 **결제 -> 주문**으로 **서열/의존**이 있지만, 후자의 이벤트 모델에서는 결제 시스템은 그저 사실을 알렸을 뿐이고 주문 시스템은 그 사실을 **자율적으로 해석**해 행동합니다. 만약 주문 시스템이 다운이더라도, 이벤트는 큐에 쌓이고 결제 시스템은 몰라도 되며(둘은 느슨하게 연결), 주문 시스템이 복구되면 이벤트를 처리하면 됩니다. 이는 **논리적 완충지**(buffer)를 제공하여, **일시적 모순**이나 **지연**을 허용하는 대신 **전체 시스템의 탄력성(resilience)**을 높입니다.

하지만 EDA에도 **단점이나 고려사항**이 있습니다. 무엇보다 **결과적 일관성** 문제가 전 시스템적으로 나타납니다. 여러 컨텍스트가 이벤트로 동기화되므로, 항상 모든 부분이 동시에 최신 상태를 갖지는 못합니다. 또한 **트랜잭션 경계**가 개별 시스템으로 분리되기 때문에, 한 이벤트에 반응하는 다수 시스템의 작업들이 **원자적**으로 처리되지 않습니다. 그 결과, **Saga**와 같은 패턴이 필요해질 수 있습니다. Saga는 다음 절에서 다루겠지만, EDA 환경에서 **분산 트랜잭션**을 논리적 프로세스로 풀어내는 방법입니다.

또한 EDA에서는 **메시징 인프라 의존성**이 추가됩니다. 메시징 시스템 자체가 **싱글 포인트**가 되거나, 성능 병목이 될 수 있으므로 견고한 메시지 브로커가 필요합니다. **이벤트 설계** 자체도 고려사항입니다: 어떤 이벤트를 발행할지, 이벤트 내용(payload)에 어떤 데이터를 담을지, 이벤트의 **schema(발행된 언어)**를 컨텍스트 간 어떻게 합의할지 등이죠. DDD에서는 이벤트 명에도 **유비쿼터스 언어**를 적용하고, 이벤트 필드도 풍부하게 담아 **이후 확장에 대비**하도록 권장합니다.

4장에서는 *“한 육각형(컨텍스트)에 들어오고 나가는 이벤트에는 여러 종류가 있을 수 있지만, 우리가 특히 관심 갖는 것은 도메인 이벤트이다”*라고 강조합니다. 시스템 모니터링이나 로깅 같은 이벤트도 있을 수 있지만, **모델링에 주의를 요하는 것은 도메인 이벤트**라는 것입니다. 이는 핵심 비즈니스 흐름은 **도메인 이벤트**로 연결하고, 기술적 이벤트들은 별도로 취급하라는 뜻으로 읽힙니다. 또한 _“엔터프라이즈 차원에서 EDA 방식을 지원/보완하는 헥사고날 아키텍처 뷰를 원하는 만큼 복제할 수 있다”_고 하여, 필요하다면 여러 컨텍스트에 걸쳐 EDA를 적용할 수 있음을 시사합니다. 굳이 모든 시스템이 헥사고날일 필요는 없지만, 헥사고날이라면 EDA와 잘 맞으며 계층 구조라도 EDA에 참여시킬 수 있다는 유연함도 언급합니다.

정리하자면, **이벤트 주도 아키텍처**는 **전제**: 시스템 간 강한 결합과 동기 통신은 확장성과 탄력성에 문제를 일으킨다. **접근**: 도메인 이벤트를 활용한 발행-구독 패턴으로 느슨한 연결을 만든다. **결론**: 각 시스템은 메시징 인프라와 이벤트 계약만 따르면 독립적으로 진화 가능하며, 전체적으로 확장 가능하고 반응적인 구조가 된다.

이 구조에서, DDD의 도메인 이벤트는 **사건의 의미**를 명확히 정의함으로써, 이벤트 스트림을 통한 **비즈니스 의미의 통신**을 가능케 합니다. 이벤트는 단순 신호가 아니라, *“무엇이 일어났는가”*에 대한 **사실 서술**이고, 이를 받는 쪽은 _자신의 컨텍스트에서 이 사실이 갖는 의미_를 판단하여 조치를 취합니다. 예컨대 “고객 등급 상승 이벤트”는 마케팅 컨텍스트에서는 새로운 혜택을 부여하는 의미일 수 있고, 다른 컨텍스트에선 아무 의미 없을 수도 있습니다. 실제 본문도 *“수신된 다양한 도메인 이벤트는 이를 수신하는 바운디드 컨텍스트 내에서 특정한 의미를 가질 수도 있지만, 아무 의미를 갖지 않을 수도 있다”*고 언급합니다. 흥미로운 점은, 어떤 컨텍스트에 의미 없는 이벤트는 그냥 무시하면 그만이고, 의미 있는 이벤트만 다루면 됩니다. 이 또한 **논리적 독립성**을 보여주는 면입니다. 각각의 컨텍스트는 자신만의 **논리적 이론**을 갖고 있고, 이벤트는 그들에게 **공통 사실**로 전달되지만, 받아들일지 말지는 각자의 논리(유비쿼터스 언어/비즈니스 규칙)에 따라 결정됩니다.

마지막으로 EDA에 대한 **논리적 비유**를 하자면: 이는 **비동기 메시지 교환을 통한 다중 계승 논증**과 같습니다. 한 사건 $E$가 있으면, 시스템 $A, B, C...$가 각각 “If $E$ then do F”“If $E$ and condition X then do G” 같은 규칙(전제->결론)을 가지고 반응하는 것이지요. 중앙 조정자가 없이도 전체로서는 합의된 결과(결론들 집합)가 나오게 됩니다. 이러한 **분산 논증 구조**는, 앞서 본 REST가 하나의 클라이언트-서버 논증 체계라면, EDA는 **여러 행위자들이 한 사건을 두고 각자 논리 작업을 전개하는 병렬 추론 체계**라고 볼 수 있습니다. 이 체계가 잘 유지되려면 각자 **전제의 의미**(이벤트 정의)에 합의를 해야 하고, **충돌하는 추론**이 없도록 이벤트 설계와 핸들러 설계에 신경 써야 합니다.

## 파이프와 필터: 메시지 처리의 논리 파이프라인

4장에서는 이벤트 주도 시스템을 구현하는 기법 중 하나로 **파이프와 필터 패턴**도 소개됩니다. **파이프(Pipe)**와 **필터(Filter)**는 소프트웨어 공학의 고전적 패턴으로, _데이터 처리 파이프라인_을 구성하는 방식입니다. 유닉스의 `|` 파이프 개념에서 이름을 따왔으며, **일련의 필터(프로세서)들이 데이터를 순차 변환**하여 최종 결과를 얻는 구조입니다.

이 패턴을 **메시지 기반 EDA**에 적용하면, 이벤트 메시지가 시스템 내에서 여러 단계를 거쳐 가공/라우팅될 수 있습니다. 4장에서는 표 4.2를 통해 메시징 기반 파이프-필터의 특징을 정리했는데, 주요 포인트를 간추리면 다음과 같습니다:

- **파이프**: 메시지 채널(channel)입니다. 필터의 출력은 파이프를 통해 다음 필터의 입력으로 전달됩니다. 여러 가지 전송 수단(JMS Queue, Kafka Topic 등)이 파이프 역할을 할 수 있습니다.
    
- **필터**: 입력 파이프에서 메시지를 받아 처리하고, 필요한 경우 출력 파이프로 메시지를 내보내는 **처리기(processor)**입니다. 필터는 꼭 “필터링” (걸러내기) 동작만 하는 건 아닙니다. 변환, 분기, 집계 등 다양한 처리를 합니다.
    
- **포트**: 필터들을 파이프에 **연결**하는 접점으로, 사실상 헥사고날에서 말하는 포트와 유사한 역할을 합니다. 즉 필터 간에도 인터페이스 규약이 있어야 하고, 그 접속점이 포트입니다. (이 부분은 기술적 상세이지만, 헥사고날과 일맥상통함을 보여줍니다).
    
- **분리된 처리기 & 느슨한 결합**: 각 필터는 독립적인 컴포넌트로서, 다른 필터의 내부에 의존하지 않습니다. 오직 입력 메시지 내용에만 의존합니다. 따라서 필터의 추가/제거/재배치가 자유롭고, 시스템 구성(configuration)만 바꾸면 프로세싱 흐름을 변경할 수 있습니다.
    
- **교환 가능성(Interchangeability)**: 필터들의 순서는 **유스케이스 요구마다 재구성**될 수 있습니다. 한 마디로, 파이프-필터 사슬을 상황에 맞게 조합할 수 있다는 것입니다. 이 조합은 설정으로 정의되고 쉽게 바꿀 수 있습니다.
    

예를 들어, 이벤트 메시지가 “주문 생성됨”이라고 할 때, 이를 처리하는 파이프라인을 만들어봅시다. 첫 번째 필터는 “이벤트 유효성 검사”를 하고, 두 번째 필터는 “이벤트를 다른 부서별로 분기”하고, 세 번째 필터는 “각 부서의 하위 시스템으로 전달”하는 식입니다. 파이프-필터 패턴을 사용하면 이 일련의 과정을 **연속된 작은 단계들**로 구현합니다. 만약 새로운 요구로 “로그 남기기” 필터를 추가하고 싶다면, 해당 지점에 필터를 끼워넣으면 됩니다. 전체 시스템을 크게 손대지 않고도 기능 추가가 가능합니다. 필터 각각은 **단일 책임**을 가지므로 이해하기 쉽고 테스트하기도 좋습니다.

DDD와의 관련성을 보자면, 파이프-필터는 주로 **애플리케이션 계층이나 인프라 계층에서의 처리 흐름**을 조직하는데 쓰입니다. 도메인 이벤트를 후처리하거나, 외부 시스템과의 데이터 변환에 이 패턴을 적용할 수 있습니다. 예컨대, “주문 완료” 이벤트를 받아 **필터1**: 송장 생성 이벤트로 변환, **필터2**: 회계 시스템 메시지로 변환, **필터3**: 해당 시스템 큐로 전달 – 이런 식이죠. 각각의 필터는 도메인 규칙이 아니라 기술/통합 로직이기 때문에, **도메인 모델과 분리**된 어플리케이션 서비스나 메시징 구성요소로 구현됩니다. 헥사고날 아키텍처에서 보면, **입력 어댑터** 내부나 **도메인 이벤트 처리기** 쪽에서 이 패턴이 활용될 수 있습니다.

4장에서는 파이프-필터 패턴을 **커맨드 라인 파이프-필터**와 비교하며 설명합니다. 유닉스 커맨드 라인 파이프에서는 각 필터가 표준입력/출력으로 한 줄씩 데이터를 받고 내보내죠. 메시징 환경의 파이프-필터는 이와 비슷하지만 **동시성과 병렬성**을 더 잘 지원합니다. 메시징 필터는 여러 파이프(채널)를 동시에 다룰 수 있고, 같은 타입의 필터를 병렬 배치해 **스케일 아웃**할 수도 있습니다. 예를 들어, 처리량이 많다면 필터 인스턴스를 3개 돌려서 3개의 병렬 파이프라인이 동시에 메시지를 처리하도록 할 수 있습니다.

**논리적 관점**에서 파이프-필터 패턴은 **함수 합성**과 대응됩니다. 각 필터를 하나의 함수 $f_i$로 보면, 입력 메시지 $m$가 차례로 $f_1(f_2(...f_n(m)...))$ 형태로 적용됩니다. 함수 합성은 결합 법칙과 단위 함수를 가지고 수학적으로 잘 정의된 연산입니다. 파이프-필터 역시 이러한 **합성의 법칙**을 갖습니다. 잘 설계하면, 필터끼리 자유롭게 조합해도 최종 결과의 **의미적 정합성**이 유지되도록 만들 수 있습니다. (물론 필터끼리 계약을 맞춰야 하지만, 그 계약이 바로 메시지 스키마나 포맷입니다.)

정리하면, **파이프-필터 패턴**은 EDA나 메시징 시스템 안에서 **복잡한 처리를 작은 단계들의 연쇄로 분해**하는 설계입니다. **전제**: 복잡한 변환/처리 과정을 하나의 거대한 블록으로 구현하면 유연성이 떨어지고 변경이 어렵다. **대안**: 단계별 모듈화 – 각 단계(필터)는 단일 기능 수행, 단계 사이 데이터는 표준화된 포맷(메시지)으로 연결. **결론**: 새로운 단계 추가, 단계 순서 변경 등이 구성으로 가능해지며 시스템 적응성이 증가한다. 이러한 처리 파이프라인은 특히 **이벤트 스트림 처리**, **데이터 파이프라인(ETL)**, **클라우드 서버리스에서의 함수 체인** 등 현대 분산 시스템에서 널리 쓰이는 개념입니다.

DDD 측면에서 생각할 때, 파이프-필터는 **도메인 로직 그 자체를 바꾸진 않습니다**. 대신 **도메인 이벤트를 전달하거나, 여러 컨텍스트 간 통합 논리를 구현하는** 기술적 패턴입니다. 예를 들어, 이벤트 브로커에서 **필터**: 이벤트 디코딩 -> **필터**: 이벤트를 여러 구독자 큐로 브로드캐스팅 -> **필터**: 각 큐로 전송 이런 식일 수 있죠. 각각은 비즈니스 로직은 아니지만, 시스템의 **신뢰성과 확장성**을 높이는 기술 로직입니다. DDD에서 흔히 말하는 “도메인 이외 부분(Infrastructure, Application)을 깨끗하게 유지”해야 한다는 원칙과 부합하게, 이러한 부분을 깔끔한 패턴으로 구조화함으로써 **전체 시스템이 이해하기 쉬운 논리**를 갖게 됩니다.

## 장기 실행 프로세스(Saga): 분산 트랜잭션의 논리적 관리

**장기 실행 프로세스**는 4장의 마지막 부분에 등장하는 개념으로, 일종의 **비동기 워크플로우 또는 Saga 패턴**을 가리킵니다. 영어권에선 주로 “Saga”라고 부르며, 이는 **여러 단계로 구성된 비즈니스 트랜잭션을 조정하는 패턴**입니다. 각각의 단계는 독립적인 트랜잭션으로 커밋되고, 전체가 성공해야 최종 완료로 간주하며, 중간에 실패 시 **보상 작업(compensating action)**을 수행해 이전 단계를 취소/반영 취소합니다.

4장에서는 **GemFire** 같은 데이터 그리드에서 제공하는 **Function(함수)**나 **Coherence**의 Entry Processor 등을 활용한 예제를 보여줍니다. 그 코드에서는 `PhoneNumberCountSaga extends FunctionAdapter` 형태로 Saga를 구현했는데, 이는 특정 지역(분산 캐시 파티션)에 분산되어 있는 전화번호 데이터를 병렬로 집계하는 프로세스였습니다. 이 Saga는 두 가지 숫자를 병렬 계산합니다: 필터에 맞는 전화번호 개수와 전체 전화번호 개수, 그리고 둘을 합쳐 결과 리스트를 반환합니다. 이 예는 금융 거래나 주문 처리 같은 전형적인 Saga보다는, **대용량 데이터 병렬 처리**에 초점이 있었습니다. 핵심은, **여러 노드에 흩어진 데이터를 병렬로 처리하고 그 결과를 모아서 제공**하는 **긴 프로세스**를 하나의 Saga(혹은 분산 함수)로 표현한 것입니다.

이 예제를 통해 유추할 수 있는 **논리적 메시지**는: **어떤 작업이 하나의 단일 트랜잭션으로 수행될 수 없거나, 너무 오래 걸려 사용자 대기에는 부적합할 때, 이를 관리하는 별도 프로세스가 필요**하다는 것입니다. DDD 컨텍스트에서 **도메인 서비스**나 **애그리게잇**은 짧은 트랜잭션(보통 몇 초 이내, ACID 보장) 처리를 전제로 합니다. 그러나 **장기 실행 프로세스**는 수십 초, 수분, 심지어 수시간 걸릴 수도 있는 프로세스이며, 여러 시스템 또는 여러 데이터 소스를 거칩니다. 이런 프로세스를 관리하려면 **논리적 오케스트레이션**이 필요합니다.

Saga 패턴을 일반화해 보면:

- **전제**: 분산된 여러 단계 (T1, T2, ..., Tn)을 차례로 또는 병행으로 수행해야 목표를 달성하는 비즈니스 시나리오가 있다. 각 단계는 자체 트랜잭션(데이터 변경)을 포함한다. 한 단계 실패 시 이미 완료된 이전 단계들을 취소하거나 보정해야 전체 데이터 정합성이 유지된다.
    
- **솔루션**: 중앙 조정자 또는 이벤트 기반 조정 (오케스트레이션 vs 코레오그래피)을 통해 각 단계를 **순차/병렬 실행**하고, 단계 간 데이터를 전달하며, 오류 시 보상 트랜잭션을 실행하는 흐름을 구현한다. 이 조정 로직 자체를 하나의 컴포넌트(프로세스 관리자)로 분리한다.
    
- **결과**: 전체 프로세스가 마치 하나의 트랜잭션처럼 **논리적 일관성** 단위를 이룹니다. 즉 모든 단계 완료 시 최종 성공 (Commit All), 중간 실패 시 각 완료 단계별 Undo (Compensate) 수행 후 프로세스 실패 (Rollback All)에 준하는 효과를 얻게 됩니다.
    

4장의 GemFire 예시는 Saga의 고전적 예 (주문 – 결제 – 재고 – 배송 연결 등)은 아니지만, **병렬 분산 처리 + 결과 집계**라는 관점에서 Saga와 유사한 구조를 가집니다. 여기서 Saga (Function)가 **병렬로 실행되는 부분 함수들의 결과를 모아준다**는 것은, Saga 패턴에서 각 단계의 결과를 모아서 전체 결과를 내는 것과 비슷합니다. 다만 일반 Saga는 보상 및 상태 전이가 중요 이슈인데, 이 예시는 읽기 연산이라 보상은 필요 없었던 셈입니다.

4장은 “어쩌면 여러분은 이를 도메인 서비스 개념으로 생각할 수도 있지만, 그런 생각은 결국 도메인 중심에 맞지 않게 귀결될 수 있다”라고 언급하며, GemFire 기능 등을 예로 든 것을 방어합니다. 이 문장은 **장기 실행 프로세스의 조정 로직을 도메인 서비스로 두지 말라는 뜻**으로 해석됩니다. 도메인 서비스는 **순수한 도메인 계산/규칙**에 집중해야지, 분산 환경 제어나 병렬성 관리 등의 인프라 논리를 담으면 안 된다는 것입니다. Saga 로직은 보통 **애플리케이션 계층**이나 **별도 프로세스 관리자**에서 구현하고, 도메인 개입은 최소화하는 것이 모범적입니다. 이는 논리적으로 **관심사 분리** 원칙에 부합합니다. 도메인 모델은 *"무엇이 해야 하는 일인가"*를 정의하고, Saga 프로세스는 *"그 일을 여러 부분에 나눠 어떻게 수행할 것인가"*를 관리하죠.

Saga를 예를 들어 설명하면, **온라인 주문**에서 다음과 같은 단계가 있을 수 있습니다: `재고 감소` -> `결제 승인` -> `배송 지시`. 전통적으로는 이 3가지를 하나의 긴 트랜잭션에 묶으려 할 수 있으나, 서로 다른 서비스(DB)일 경우 이는 불가능합니다. Saga 오케스트레이터는 먼저 재고 감소(단계1)를 실행하고 성공시 단계2로 진행, 만약 단계2 (결제)에서 실패하면 단계1을 취소(재고 증가 보상)하고 종료. 단계2 성공하면 단계3 실행, 단계3 실패하면 단계2 보상(결제 취소), 단계1 보상(재고 복구) 등... 이런 논리를 코드나 설정으로 짜 놓는 것입니다.

이 오케스트레이터는 **상태 기계**처럼 동작할 수도 있습니다. 각 단계 완료 시 Saga의 상태를 업데이트하고, 다음 단계 이벤트를 트리거하며, 실패 시에는 상태에 따라 어떤 보상할지 결정합니다. 4장에서는 이런 구현 세부까지 들어가진 않았지만, **GemFire Function**을 Saga로 활용한 부분에서 상태 제한을 위한 filter를 언급합니다: _“함수에는 매칭되는 애그리게잇 인스턴스의 수행을 제한하는 필터를 등록할 수 있다”_. 이는 특정 ID의 데이터에 대해서만 함수 실행 등의 제어를 하는 부분 같네요.

또한, 4장은 GemFire 예시를 통해 **데이터 그리드 기반의 병렬 처리 Saga**를 보여주고, 그 **클라이언트 코드**도 소개했습니다. 이 부분은 기술 상세이지만, _FunctionService.onRegion(...).withFilter(...).execute(...)_ 식으로 Saga를 실행하는 예를 보여주고 있습니다. 중요한 것은, 개발자가 도메인 객체 메서드를 직접 반복 호출하는 대신, **분산 인프라**의 기능을 활용해 Saga를 효율적으로 수행하고 있다는 점입니다.

**논리적 관점**으로 Saga를 평가해 보면, Saga는 **전역 불변조건**을 지키기 위한 **프로토콜**입니다. 여러 시스템/자원에 걸쳐 `P1, P2, ..., Pn`이라는 개별 불변조건들이 있고, Saga는 이들이 연쇄적으로 만족되도록 또는 다 같이 롤백되도록 **논리적 시퀀스**를 짠 것입니다. Saga의 **보상 트랜잭션**은 논리적으로 해당 단계의 **역함수(inverse)** 역할을 해야 합니다. 단계2의 보상은 단계2의 효과를 취소하는 함수, 단계1의 보상은 단계1을 취소하는 함수 등. 수학적으로 말하면, Saga가 `T1; T2; T3` 합성이라면, 보상은 `T3^{-1}; T2^{-1}; T1^{-1}` 합성인 셈입니다. 모든 $T_i$가 원자적으로 commit/abort 되므로, Saga 전체로 보면 원자성 비슷한 효과를 냅니다. 단, **동시에 일어나지 않고 시간차가 있을 뿐**입니다. 그래서 Saga는 **ACID** 대신 **BASE** (Basically Available, Soft state, Eventual consistency) 원칙에 가까운, 느슨한 트랜잭션이라 할 수 있습니다.

4장의 맥락에서 Saga(장기 실행 프로세스)는 **CQRS/EDA와 함께** 소개되었기 때문에, 자연스레 **이벤트 주도 통신과 Saga**의 조합을 생각해볼 수 있습니다. Saga를 구현하는 두 가지 방법:

1. **Orchestration (중앙집중)**: 하나의 Saga 오브젝트/서비스가 전체 과정을 진행. (4장의 GemFire 예시, 혹은 주문 Saga Coordinator 등)
    
2. **Choreography (분산)**: 중앙 조정자 없이 이벤트로 단계 전이가 이루어짐. 예를 들어, 주문 생성 이벤트 -> 결제 서비스가 듣고 처리 후 “결제완료” 이벤트 -> 배송 서비스가 듣고 처리... 이런 식으로 이벤트 릴레이.
    

두 방식 모두 DDD 맥락에서 쓰입니다. Orchestration은 구현이 명시적이고 추론이 쉬운 반면, Choreography는 결합도가 낮지만 추론이 어렵고 숨겨진 의존이 생길 수 있습니다. 4장에서는 Saga를 Orchestration 개념으로 다룬 것으로 보입니다 (코드로 작성된 function, saga class를 보여주므로).

결론적으로, **장기 실행 프로세스(Saga)**란 **여러 분산작업에 걸친 논리적 트랜잭션**입니다. **전제**: 하나의 ACID 트랜잭션으로 처리 못하는 다단계 작업이 필요하다. **방법**: 프로세스 관리자(오케스트레이터) 혹은 이벤트 연쇄(코레오그래피)로 각 단계 처리 및 오류 시 보상 흐름을 구현한다. **결론**: 시스템은 **항상성(invariant)**을 최종적으로 만족하게 유지하면서도, 분산 환경에서 **유연한 트랜잭션 관리**를 달성한다. DDD에서 중요한 것은, Saga의 각 단계가 여전히 **도메인 논리**의 일부라는 것입니다. Saga의 존재를 반영해 **도메인 이벤트**들을 정의하고, 각 컨텍스트가 그 이벤트를 처리하는 규칙을 마련해야 합니다. Saga 자체는 비즈니스 프로세스를 표현하므로, DDD의 **도메인 모델을 넘어 프로세스 모델** 영역으로 확장하는 개념이라고 볼 수 있습니다.

## 이벤트 소싱(Event Sourcing): 상태를 사건의 흐름으로 인식하는 논리

4장은 **이벤트 소싱(Event Sourcing)**도 다룹니다. 이벤트 소싱은 데이터 **저장(persistence)**의 패러다임 전환으로 볼 수 있는데, 기존에는 엔티티의 **현재 상태만 저장**했다면, 이벤트 소싱에서는 **그 엔티티와 관련된 모든 변경 이벤트를 시간순으로 저장**합니다. 다시 말해, **상태 = 이벤트의 이력(history)을 재생한 결과**로 간주합니다.

이벤트 소싱의 **핵심 개념**은 다음과 같습니다:

- 각 애그리게잇(혹은 Entity)은 고유 ID를 가지며, 관련된 **도메인 이벤트**들의 시퀀스를 갖는다.
    
- 저장소에는 최신 상태 대신, **이벤트 스토어(Event Store)**라는 형태로 **이벤트 기록**이 쌓인다. 예를 들어 BankAccount 애그리게잇이라면 “계좌개설, 입금100, 출금30, 출금20, …” 이런 이벤트 목록이 저장되는 것입니다.
    
- 객체를 메모리에 로드할 때는, **해당 ID의 이벤트들을 시간순으로 재생(replay)**하여 객체를 초기 상태부터 현재까지 복원합니다. 마치 수학적 fold(畳み込み)를 하는 것과 같습니다.
    
- 원활한 복원을 위해 **스냅샷(snapshot)**을 도입하기도 합니다. 예컨대 이벤트가 수천 개로 늘어나면, 중간 시점의 객체 상태를 스냅샷으로 저장해두고, 로드 시 그 이후의 이벤트만 재생합니다. 스냅샷 주기는 시스템에 맞게 (예: 100개 이벤트마다) 정합니다.
    

4장은 이벤트 소싱의 **기술적 특징**과 **장단점**을 논의합니다. 먼저, *“영속성 메커니즘으로서 이벤트 소싱은 ORM 도구 사용을 대체할 수 있으며, 둘은 상당히 다르다”*고 말합니다. 구체적으로:

- 이벤트 소싱에서는 **이벤트 저장소(Event Store)**를 씁니다. 이벤트는 흔히 **직렬화된(binary) 형태**로 저장되기에, 전통적인 SQL 질의를 통해 **임의의 조회**를 하기 어렵습니다. (예를 들어, “잔액 100 이상인 계좌 찾기” 같은 질의는 이벤트 스트림만으로는 간단치 않습니다).
    
- 이벤트 소싱 기반 **Repository**는 오직 하나의 조회 메소드 (ID로 이벤트 스트림 가져오기)와 저장 메소드(새 이벤트 추가)만 있으면 됩니다. find(id) 하면 그 ID의 이벤트들 목록 반환 -> Aggregate recreate; save(agg) 하면 그 agg의 새 이벤트들을 가져와 저장.
    
- 이벤트 소싱된 Aggregate은 **조회 메소드(getters)가 아예 없다**고 강조합니다. 애초에 그 Aggregate에서는 외부에서 상태를 직접 읽을 필요가 없고, 조회는 따로 CQRS의 읽기 모델로 할 것이기 때문입니다. Aggregate은 오직 행동 메소드 (command)만 있고, 그 행동 결과로 이벤트를 내놓습니다.
    
- 따라서 **CQRS와 이벤트 소싱은 궁합이 좋고, 긴밀히 결합해 사용**됩니다. 쓰기 모델 Aggregate은 이벤트 생성에 집중하고, 읽기 모델은 이벤트가 쌓일 때마다 별도 DB로 projection을 업데이트하여 조회를 담당합니다.
    
- 이벤트 소싱을 채택하면, **모든 상태 변화가 도메인 이벤트로 표출**되므로, **도메인 이벤트를 적극적으로 모델링**해야 합니다. 이는 DDD의 장점(이벤트라는 또 하나의 모델을 통한 의사소통)을 극대화하지만, **복잡성 증가**도 수반합니다. 개발자는 객체 상태 변경 코드를 단순히 쓰는 대신, 반드시 적절한 이벤트를 만들어내는 로직을 작성해야 합니다.
    

4장은 이벤트 소싱의 **이득(gains)**에 대해서도 서술합니다. _“가장 기본적으로, 이벤트 히스토리가 시스템의 버그를 해결하는 방법을 보여줄 수 있다”_. 이는 이벤트 소싱의 유명한 이점인 **Audit Trail(감사 추적)**과 **디버깅 용이성**을 가리킵니다. 모든 변경 내역이 남아 있으니, 어떤 버그나 이상 현상이 발생했을 때 **시간을 거슬러 추론이 가능**합니다. 예컨대 “이 계좌 잔액이 음수가 되었는데 왜지?” 하면, 이벤트 로그를 따라가며 잘못된 이벤트(예: 중복 인출 이벤트 등)를 발견할 수 있습니다. 이는 불변의 진리인 *“과거를 알아야 현재 상태를 정확히 이해할 수 있다”*를 시스템이 구현한 것입니다. 물리학의 원리처럼, 상태는 사건의 누적으로 결정된다는 것을 소프트웨어에 적용했다고 볼 수 있죠.

그 외 이벤트 소싱의 장점으로 종종 언급되는 것:

- **시뮬레이션 & 프로젝션**: 이벤트 이력을 가지고 미래 시나리오를 시뮬레이트하거나, 새로운 계산에 활용할 수 있습니다. (e.g., 특정 이벤트를 빼고 재생해본다거나)
    
- **완전한 감사 로그**: 규제 산업에서 데이터 변경 추적이 필수인데, 이벤트 소싱은 이를 자연스럽게 충족합니다.
    
- **출판/통합 용이**: 이벤트 저장 시, 동시에 그 이벤트를 메시지로 발행하면, **EDA**를 구현하기 쉽습니다. 시스템 내부 저장과 외부 전파를 한 번에 해결하는 셈입니다. (Event Store에 Commit -> 메시지 브로커로 해당 이벤트도 퍼블리시)
    
- **확장성**: 쓰기 부하를 견딜 수 있습니다. 이벤트 저장은 **append-only**(계속 쓰기만)라 전통 RDB update보다 성능, 확장에 유리합니다. 또한 분산 Event Store (Kafka 등으로도 구현 가능) 사용 시 분산 처리가 자연스럽습니다.
    

그러나 **단점/과제**도 분명합니다:

- **질의 어려움**: 앞서 언급한 대로, 이벤트 로그만으로 특정 질의 답을 구하기 어렵습니다. 거의 반드시 **별도 조회 모델**이 필요하고, 이는 시스템 복잡성 추가입니다.
    
- **개발 난이도**: 사고방식 전환이 필요합니다. 개발자가 CRUD에 익숙하면, 이벤트 단위로 생각하고 설계해야 하니 러닝커브가 있습니다.
    
- **이벤트 설계의 선험성**: 미래 요구를 예상 못하고 이벤트를 설계하면, 나중에 필요한 데이터가 이벤트에 없어서 곤란해질 수 있습니다. 한 번 저장된 이벤트는 불변이므로, 확장 시에는 새로운 이벤트 타입 도입 등으로 대응해야 합니다.
    
- **스토리지 용량**: 이벤트 로그는 당연히 현재 상태만 저장하는 것보다 많이 공간을 차지합니다. 하지만 디스크가 쌈싸먹는 요즘은 큰 문제 아니라고들 하죠.
    

4장의 설명에서 특히 DIP, CQRS 맥락과 엮어서 본다면, 이벤트 소싱은 **DIP에 의해 역전된 의존**을 잘 활용한 예입니다. 도메인 모델이 이벤트 인터페이스를 정의하고, 저장소는 그 이벤트를 저장하는 구현체일 뿐입니다. Aggregate -> EventStore 의존을 인터페이스로 뒤집어, Aggregate이 EventStore 인터페이스에 이벤트 append 요청을 보내면, 실제 DB layer가 이를 처리하는 식일 겁니다. Domain은 구체 DB(Oracle, Mongo 등) 전혀 몰라도 되고, EventStore 구현만 바꾸면 RDB->NoSQL 쉽게 교체도 가능하죠.

또 CQRS와 떼래야 뗄 수 없다는 점을 다시 짚으면, **이벤트 소싱 없이는 CQRS 읽기 모델 최신화**가 번거롭습니다. 이벤트 소싱하면 “신뢰할 수 있는 변경 이벤트 스트림”이 기본으로 존재하니, 이를 Listen해서 읽기 DB를 갱신하면 됩니다. 이벤트 소싱 안 하면, write DB에 trigger 걸거나, write 동작 후 수동 publish하거나 등의 추가 작업이 필요하죠. 그러니 CQRS 쓰려면 이벤트 소싱 도입이 자연스레 따라오는 경우가 많습니다.

**논리적 비유**로 이벤트 소싱을 말해보면, **수학적 미분 적분**에 비유 가능합니다. **전통**: 현재 상태 = 누적 결과만 저장 (이건 마치 $f(t)$값만 알고 $f'(t)$는 모르는 상태). **이벤트 소싱**: 현재 상태를 만드는 미분/변화 $f'(t)$ (이벤트들)을 다 저장. 그래서 필요하면 이를 적분해 $f(t)$를 구함. $f'(t)$의 기록이 있으니, 다른 적분 경로로 여러 함수를 만들 수도 있습니다. 즉, 다른 projection (읽기 모델)도 $f'(t)$를 쓰면 구할 수 있죠.

한편, 이벤트 소싱은 **시간**을 일급시민으로 취급합니다. 전통 DB는 마지막 값만 남기니 시간이 제거되지만, 이벤트 로그에는 시간이 흐름에 따라 순서가 남아있습니다. 논리학 중에서도 **시간 논리 (Temporal Logic)**나 **이력 로그**에 익숙해야 모델링하기 좋습니다. 어떨 때 이 이벤트들이 동시에 혹은 순차적이어야 하는지, **event ordering** 문제도 고려해야 하니까요.

4장은 마지막으로, 이벤트 소싱 사용 시 **왜 이점이 있는지 반드시 확인해라**라고 권고합니다. 왜냐하면 이벤트 소싱은 설계 방향을 전통과 다르게 끌고가므로, 그 **Trade-off**를 이해해야 한다는 것이지요. 앞서 언급한 **디버깅 용이성**이 가장 기본적 이익이고, 더 나아가 **분산 환경에서의 강력한 인테그리티 추적**, **replay 통한 새로운 인사이트 도출** 등 고급 이익도 있습니다. 그러나 “복잡성 증가”도 무시 못하기에, 충분한 가치가 있을 때 적용하라는 뜻으로 해석됩니다 (CQRS나 Event Sourcing 모두 “필요할 때만” 쓰라 했던 맥락).

정리하면, **이벤트 소싱**은 **상태를 사건으로 기록하고, 사건의 축적으로 상태를 얻는 패턴**입니다. **전제**: 상태 변경 이벤트들이 의미 있고, 이력 관리가 가치 있으며, 조회모델과 eventual consistency를 감당할 수 있다. **결정**: 상태 대신 이벤트 저장, replay로 상태 복원. **결과**: 완전한 변경 이력 확보, 도메인 이벤트를 중심으로 시스템 운용, CQRS와 결합 시 확장성/성능 이점. 단, 쿼리 어려움은 별도 투영으로 해결 (CQRS). **논리적 의미**: 시스템은 **선형 논리**(시간 순의 사건 나열)로 상태를 파악하며, **이력=원인, 현재=결과**라는 인과 모델을 구현합니다.

## 데이터 패브릭/그리드, 복제, 지속적 쿼리, 분산 처리: 현대 분산 환경의 논리적 도구들

4장의 마지막 부분에서는 DDD를 구현함에 있어 고려할 수 있는 다양한 **분산 컴퓨팅 기법**들이 언급됩니다: **데이터 패브릭과 그리드 기반 분산 컴퓨팅**, **데이터 복제**, **지속적 쿼리(Continuous Query)**, **분산 처리** 등이 그것입니다. 이들은 특정 제품이나 기술 스택(Pivotal GemFire, Oracle Coherence 등)의 기능을 가리키지만, 개념적으로 일반화해볼 수 있습니다.

- **데이터 패브릭 / 데이터 그리드**: 이는 메모리 기반의 **분산 캐시/데이터 저장** 인프라입니다. 여러 노드에 데이터가 분산되어 저장되고, 각 노드에서 데이터에 대한 연산을 수행할 수 있습니다. GemFire, Hazelcast, Infinispan 등이 그 예입니다. 이런 기술은 DDD에서 **대용량 애그리게잇**을 다루거나 **고성능 요구**가 있을 때 고려됩니다. 논리적으로, 이는 **일종의 분산된 저장소 + 분산된 계산 공간**을 제공하므로, Repository 구현을 이 위에 할 수 있고, Saga나 CQRS query model도 이런 캐시에 둘 수 있습니다. 4장 GemFire 예시가 바로 이런 데이터 그리드 위에서 Saga 수행한 것이죠.
    
    DDD에서 중요한 점은, **도메인 모델이 이런 인프라에 크게 의존하지 않도록 인터페이스로 추상화**해야 한다는 것입니다. DIP의 적용처이기도 하죠. 예를 들어 Repository 인터페이스 뒤에 GemFire region을 쓸지, RDB를 쓸지 결정은 아키텍처의 선택이지, 도메인 모델이 알 바 아니라는 것입니다. Data Grid를 쓰면 **동시 사용자 수, 읽기 성능** 등이 크게 향상될 수 있는데, 이것은 시스템 요구사항(비기능 요구)에 따른 아키텍처 상의 **논리적 선택**입니다. DDD 핵심 로직은 변함 없지만, data grid를 썼더니 **성능이 좋아져 일관성 지연을 줄였다** 같은 효과가 나타날 수 있습니다.
    
- **데이터 복제(Data Replication)**: 이는 데이터를 실시간 또는 주기적으로 **여러 노드/장소에 복사**하여, **가용성**이나 **지역성(지리적 분산)**, **성능**을 향상시키는 방법입니다. DDD 관련해서는, **CQRS의 읽기 모델**을 여러 복제 노드에 둘 수도 있고, **한 컨텍스트의 데이터를 다른 컨텍스트 DB로 복제**하여, 특정 쿼리를 로컬에서 가능하게 할 수도 있습니다. 물론 후자는 컨텍스트 간 경계를 흐릴 수 있어 신중해야겠지만, 이벤트를 통한 eventual consistency 복제로서 "보고용 데이터 마트"를 각 컨텍스트에 줄 수 있다는 식이죠.
    
    논리적으로, 데이터 복제는 **동일한 진리의 사본**을 여러 개 만드는 것이므로, **동기화 논리**가 중요합니다. 이벤트 주도 패브릭에서 흔히 이런 동기화가 일어납니다. 4장도 아마 언급했을 “이벤트 주도 패브릭과 도메인 이벤트” 부분에서, **여러 컨텍스트에 데이터 복제가 일어남**을 암시했을 수 있습니다. 현재 한 컨텍스트의 DB에서 다른 컨텍스트의 DB로 Sync하는 건 안 좋지만, 이벤트를 통해 최소한의 필요한 데이터는 복제(Projection)하는 건 허용됩니다. 예를 들어, “고객 등급”은 고객 컨텍스트 주 데이터지만 주문 컨텍스트도 복사본을 이벤트로 받아 캐싱할 수 있습니다. 그럼 주문 도메인에서 고객 등급 조건으로 할인 계산 등이 가능해지는 식이죠. 중요한 것은, **복제된 데이터는 원본이 아니므로, 오직 조회/참조용으로만 쓰고 변경은 하지 않는다**는 DDD의 전략입니다 (**Anti-Corruption Layer**나 **발행된 언어**가 필요할 수도 있습니다).
    
- **지속적 쿼리 (Continuous Query)**: 이는 데이터 그리드나 이벤트 스트림 상에서 **실시간 구독형 쿼리**를 의미합니다. 예컨대 GemFire의 CqQuery, Kafka Streams의 KSQL 등. 즉, *“이런 조건에 맞는 데이터가 변경되면 알려줘”*라는 식의 쿼리입니다. DDD 맥락에서, 이는 UI나 다른 컨텍스트가 **변화를 즉각 감지**하는데 쓰일 수 있습니다. 이벤트 주도 시스템에서, 일일이 이벤트 종류별 핸들러를 다 짜지 않고, **데이터 패턴**으로 관심사를 표현하면 플랫폼이 알아서 알림을 주는 겁니다.
    
    논리적으로, Continuous Query는 **이벤트 필터링**과 비슷합니다. 일종의 **구문적 정의에 의한 구독**이라, 개발자가 하드코딩 대신, _“where price > 100”_ 같은 조건만 등록하면, 시스템이 price 변화를 모니터링해 조건 만족 시 이벤트를 발생시킵니다. 이는 **선언형 논리**(declarative logic) 접근이라, 부수효과 없는 명세에 가깝습니다. DDD에서는 주로 읽기 모델 쪽에서 “항상 최신 데이터 feed”가 필요한 경우, CQRS 읽기 DB를 continuous query로 감시하거나, 또는 UI에 push하게 쓰일 수 있습니다. 예를 들어, “주문 목록에서 상태='배송중'인 것 개수”를 실시간으로 UI 갱신하고 싶다면, continuous query를 OrderReadModel DB에 걸어서, 결과 변화시 UI에 보내도록 할 수 있습니다. 사실상 **eventual consistency의 UX 문제**를 푸는 기술 중 하나가, 읽기 모델에 continuous query/Change Data Capture 등을 써서 UI와 동기화해주는 것입니다.
    
- **분산 처리 (Distributed Processing)**: 이는 컴퓨팅 작업을 여러 노드에 분배해 **병렬 실행**하는 것입니다. 4장의 GemFire Saga 예는 이것의 전형이지요. DDD에서 분산 처리가 필요한 경우는, 애그리게잇 수천만 개에 대해 통계 내는 일, 머신러닝 피처를 계산하는 일 등 **한 컨텍스트 내 대량 데이터 작업**이나, **여러 컨텍스트 걸친 작업**입니다. DDD 엔터프라이즈 레벨에선, 분산 배치를 활용해 **컨텍스트별 마이크로서비스**를 병렬로 돌리는 것이 일반입니다만, 여기서 말하는 분산 처리는 한 컨텍스트 내에서도 **MapReduce**같은 처리를 할 수 있다는 의미로 보입니다.
    
    예를 들어, Order 컨텍스트에 1억 건 주문이 있고 전체 매출 합계를 구한다 하면, MapReduce 프레임워크로 각 노드별로 partial sum 하고 aggregator로 합칠 수 있죠. GemFire 함수처럼. DDD상 Aggregate 1억 개 루프 돌리는 건 application service 한 곳에서 못할 일이니, **인프라 레벨의 분산 연산**을 빌리는 겁니다. Domain 의미로는 “전체 매출” 같은 **도메인 질의**를 구현한 것이지만, 기술적으로 MapReduce. DIP로 이런 것도 추상화하면, Application 서비스는 “SalesReportRepository.getTotalSales(period)” 같은 메소드 호출만 하고, 구현체가 분산연산으로 동작하도록 할 수 있습니다. 그러면 도메인 코드엔 병렬처리 코드가 안보여서 깔끔하지만, 실제론 CPU 100개가 일함... 개발자 입장에선 dream이죠.
    

이러한 **분산 기술 요소**들은 4장의 마무리 부분에 속하지만, 저자가 의도한 바는 아마: "_DDD로 핵심 도메인을 잘 만들면, 그것을 받쳐줄 다양한 현대적 기술(REST, CQRS, Event, Saga, Grid 등)을 조합해 엔터프라이즈 아키텍처를 구축할 수 있다._"일 것입니다. 그리고 "_DDD가 이런 기술들과도 양립할 수 있으며, 오히려 잘 어울린다._"는 메시지겠지요 (초두에 책 소개 내용에 이런 부분 있었음: 헥사고날, SOA, REST, CQRS, 이벤트, 패브릭/그리드 등에 맞춘 DDD 사용 방법).

또 한 가지 강조된 점은 **“아키텍처에 너무 집착하지 말고 도메인 모델 우선순위를 잊지 말라”**는 부분입니다. 이는 4장뿐 아니라 Appendix나 챕터 끝에 걸쳐 나오는 조언으로 보입니다. _“아키텍처는 중요하지만 영향력은 상황에 따라 바뀐다. 올바른 우선순위를 명심하면서, **더 큰 비즈니스 가치를 지니고 더 오래 지속되는 도메인 모델**에 더 큰 관심을 두라.”_라는 문장은 본장의 핵심 철학을 관통합니다. 즉, 다양한 아키텍처 툴과 기법을 배웠지만, 궁극적으로 **가장 오래 남는 것은 잘 만든 도메인 모델**이니 그걸 간과하지 말라는 것입니다. 아키텍처는 domain model을 돋보이게 하고 지켜주는 **수단**이지, 목적이 아니라는 것입니다.

요약하면, **데이터 그리드, 복제, 지속 쿼리, 분산 처리** 등의 기술은 **DDD 구현의 최적화/확장 레이어**입니다. **전제**: 대규모 사용자의 성능, 데이터 일관성 및 가용성 요구가 있다. **도구**: 메모리 데이터 그리드, 다중 노드 복제, 실시간 변경 알림, 병렬 계산을 동원한다. **효과**: 도메인 모델을 변형하지 않고도, 시스템 비기능 요구(FURPS: 성능, 확장성 등)를 충족한다. 하지만 이 역시 **논리적 복잡성**을 추가할 수 있으므로, 도입 시 **도메인 모델과 격리**하여 (인터페이스 뒤에 숨겨) 적용하고, **전체 아키텍처를 논리적으로 검증**해야 합니다.

---

지금까지 4장의 모든 주장과 개념을 하나하나 논리학적으로 해부하고 상호 연결해보았습니다. 다음으로는 이 지식들을 학습하는 **논리적 흐름**을 어떻게 설계하면 좋을지 제안하고, 마지막으로 2025년 시점의 확장 과제를 살펴보겠습니다.

## 논리 기반의 학습 흐름 설계: 4장의 지식을 효과적으로 습득하기

4장에서 다룬 개념들은 광범위하고 서로 얽혀 있습니다. 이를 처음 배우는 학습자가 **장 순서에 얽매이지 않고**도 이해하도록, **논리적 난이도와 선행 지식**을 고려한 새로운 **학습 경로**를 제시해 보겠습니다. 각 단계마다 **필수 지식의 정수(essence)**, **그를 먼저 배워야 하는 논리적 이유**, **학습을 통해 넓어지는 시야와 얻는 지식**을 설명합니다.

**1. 도메인 격리의 기초 – 계층형 아키텍처와 DIP 배우기**

- **핵심 지식**: **계층 아키텍처**의 구조 (UI-응용-도메인-인프라 계층)와 **의존성 역전 원칙(DIP)**의 개념.
    
- **선행 이유**: 이것은 **소프트웨어 모듈화와 의존 관리의 기본 논리**입니다. 도메인 주도 설계의 큰 목표는 _도메인 로직의 순수성_인데, 이를 지키려면 먼저 기술적 요소와 분리하는 원리를 알아야 합니다. 계층화는 가장 직관적인 분리 기법이고, DIP는 그 분리의 한계를 극복하는 원칙이므로, 이후 고급 패턴의 토대가 됩니다. 논리적으로, **“상위 정책은 하위 구현 세부에 의존하지 않는다”**는 DIP는 뒤에 나올 헥사고날, 이벤트 소싱 등의 모든 패턴에 녹아있습니다.
    
- **시야와 지식 확장**: 이 단계를 습득하면, **의존성 그래프를 올바르게 그리는 방법**을 이해하게 됩니다. 어떤 방향으로 의존이 가야 변경에 강한 설계인지 논리적으로 판단할 수 있습니다. 또한 “도메인 모델은 인프라세부와 분리되어야 한다”는 DDD 철학을 기술적으로 뒷받침하는 개념을 얻습니다. 학습자는 이후 나올 패턴들을 볼 때, *“이 패턴은 DIP를 어떻게 실현하지?”*라고 스스로 질문하며 통찰할 수 있게 됩니다.
    

**2. 아키텍처 대칭성 – 헥사고날 아키텍처 (포트와 어댑터) 익히기**

- **핵심 지식**: **헥사고날 아키텍처**의 구조와 특징. 포트(인터페이스)와 어댑터(구현)의 역할, 다양한 외부 기기의 대칭적 연결, 테스트 용이성 등.
    
- **선행 이유**: 헥사고날 아키텍처는 **계층+DIP를 발전시킨 형태**입니다. 앞 단계에서 DIP 개념을 알았다면, 헥사고날은 그것을 **완전한 형태로 구현**한 사례입니다. 학습 순서상 DIP를 이해한 직후 헥사고날을 배우면, DIP로 인해 계층이 무너지고 대칭구조가 되는 과정을 자연스럽게 받아들일 수 있습니다. 그리고 이 단계에서 **도메인 로직을 중심에 두는 아키텍처 철학**을 확고히 할 수 있습니다.
    
- **시야와 지식 확장**: 헥사고날을 배우면, 학습자는 **“아키텍처적 경계와 핵심”** 개념을 체득합니다. 헥사고날 내부(코어)와 외부(어댑터들)를 구분하게 되므로, 나중에 Service Oriented나 Microservices를 접할 때 **경계 설정**의 중요성을 이미 이해하고 있게 됩니다. 또한 **테스트 우선 개발(TDD)**이나 **테스트 격리**의 이점도 체감합니다. “UI 없이도, DB 없이도 도메인 테스트 가능”이라는 것을 알면, 도메인 코드의 자급자족적 성격을 깨닫게 되고, 이는 DDD를 실천하는 마음가짐에도 영향을 줍니다. 이 단계까지 오면, 학습자는 소프트웨어 시스템을 볼 때 *“무엇이 핵심이고, 무엇이 주변인가?”*를 논리적으로 구분하는 눈을 갖춥니다.
    

**3. 시스템 경계를 넘어서 – 서비스 지향 아키텍처와 컨텍스트 경계 학습**

- **핵심 지식**: **서비스 지향 아키텍처(SOA)** 또는 **마이크로서비스** 개념, **바운디드 컨텍스트**와 서비스의 대응 관계, 하나의 컨텍스트가 여러 인터페이스(REST, 메시징 등)를 가질 수 있다는 점, 그리고 **기술 경계 vs 도메인 경계**에 대한 올바른 인식.
    
- **선행 이유**: 앞서 내부 구조(계층, 헥사고날)를 배웠다면, 이제 **시스템 대 시스템 통신**이나 **경계 간 분리**를 다룰 차례입니다. DDD의 전략적 설계에서 바운디드 컨텍스트를 정의하지만, 그것을 **아키텍처 수준**에서 구현하는 방법이 바로 서비스 지향입니다. 학습자는 헥사고날을 각 컨텍스트 내부 구조로 떠올리고, 컨텍스트들 간 통신은 서비스(API 호출 또는 이벤트)로 한다는 큰 그림을 이 단계에서 이해해야 합니다.
    
- **시야와 지식 확장**: 이 단계를 통해, 학습자는 **“시스템을 분해하고 통합하는”** 안목을 얻습니다. 어디서 경계를 그어야 할지, 서비스는 얼마나 커야 할지 감을 잡게 됩니다. 특히 **아키텍처가 도메인 크기를 결정하게 두지 말라**는 원칙을 배움으로써, 앞으로 마이크로서비스 설계 시 만연한 **오인 (엔드포인트마다 서비스화)**을 피할 수 있습니다. 또한 이 과정에서 **유비쿼터스 언어와 서비스 인터페이스 설계**의 관계를 엿볼 수 있습니다. 예를 들어, 컨텍스트 경계가 언어 경계이므로, 서로 다른 컨텍스트 간 통신 시 **번역(Anti-Corruption Layer)** 개념을 미리 이해하게 될 것입니다. 이로써 학습자는 DDD 전략적 디자인과 아키텍처의 연결고리를 확인하고, 보다 **거시적 시야**를 갖추게 됩니다.
    

**4. 웹 통합의 현실 – RESTful 아키텍처 스타일과 클라이언트-서버 상호작용 배우기**

- **핵심 지식**: **REST** 원리 (자원, 표현, 상태 전이, HATEOAS), RESTful API의 설계 방법, REST가 DDD 패턴(예: Open Host, Published Language)을 구현하는 방식, 그리고 REST의 장단점 (단순성, 표준성 vs 과도한 분해 위험 등).
    
- **선행 이유**: REST는 오늘날 가장 널리 쓰이는 서비스 통신 방식이므로, 실무 맥락에서 앞 단계(Service Orientation)와 함께 바로 학습해야 합니다. 이론적으로는 REST 없이도 서비스 연동이 가능하지만, 현실적으로 REST는 **de-facto 표준**입니다. 학습자는 REST를 배우며, 앞서 배운 바운디드 컨텍스트 간 **동기 통신**의 구체를 이해할 수 있습니다. 또한 REST를 다룸으로써 **HTTP 프로토콜 수준**에서 리소스를 어떻게 모델링하는지가 DDD와 연결됨을 봅니다.
    
- **시야와 지식 확장**: RESTful API 설계를 배우면, 학습자는 **“외부 세계에 도메인 모델을 노출하는 법”**을 알게 됩니다. URI 구조를 도메인 개념에 맞게 짜는 법, HTTP 메서드로 의도를 표현하는 법 등을 익히면서, **도메인 모델의 경계를 넘어선 부분**에도 일관된 논리가 필요함을 깨닫습니다. 또한 **HATEOAS**를 통해 _클라이언트가 동적으로 애플리케이션 상태를 탐색한다_는 아이디어는, **계약 주도 설계**가 아닌 **발견/탐색 주도 설계**라는 새로운 관점을 줍니다. 이는 이후 이벤트 주도 시스템에서 **구독자들이 필요한 이벤트를 발견**하는 그림과도 유사한 사고를 길러줍니다. REST 학습으로 **표준 미디어 타입, 콘텐츠 협상** 등의 웹 통신 개념도 얹히게 되어, 학습자는 이 시점에서 **인터넷 시대의 서비스 통합 방법**을 큰 그림에서 이해합니다.
    

**5. 복잡성 타파 패턴 – CQRS로 모델 분리와 최종적 일관성 이해하기**

- **핵심 지식**: **CQRS** 개념, 명령 모델 vs 조회 모델의 구분, 한 Aggregate의 쓰기 모델과 읽기 모델이 어떻게 생기는지, CQRS 적용 시 장점 (확장성, 집중화)과 단점 (복잡성 증가, eventual consistency).
    
- **선행 이유**: 지금까지 학습자는 비교적 **전통적인 구조와 통신**을 다 배웠습니다. 이제 시스템이 커지면서 나타나는 **성능/복잡성 문제를 해결하는 전술**을 배울 차례입니다. CQRS는 그중 핵심 패턴입니다. 학습자는 앞서 도메인 모델을 한 덩어리로 다뤄왔지만, 여기서 **“도메인 모델도 두 부분으로 찢을 수 있다”**는 사고 전환을 경험합니다. 이는 쉬운 개념이 아니므로, 앞 단계를 다 소화한 후에 배워야 합니다. 또한 RESTful 시스템 같은 **동기 통합**을 알고 나서 CQRS를 보면, “아, 이건 주로 내부 설계/성능 위한 것이구나”를 분명히 인식하게 됩니다. (REST API 상에는 여전히 한 컨텍스트지만, 내부적으로 두 DB를 운용하는 것)
    
- **시야와 지식 확장**: CQRS를 배우면, 학습자는 **소프트웨어 설계의 비선형성**을 맛봅니다. 하나의 모델을 지키는 것이 미덕이라고 생각했는데, 더 나은 목적을 위해 둘로 쪼갬을 감행하는 것이죠. 이는 **Single Responsibility Principle**의 극단적 적용으로도 볼 수 있습니다. 결과적으로, **“하나의 진실”**이 쓰기 모델과 읽기 모델로 나뉘어 관리되는 것을 보고, _진리가 하나의 원천에만 있지 않고 둘 사이의 협력으로 만들어질 수 있구나_를 이해합니다. 이로써 **데이터 중복과 일관성 관리**라는 큰 숙제를 접하게 됩니다. 학습자는 eventual consistency의 개념을 처음 받아들이게 되고, 이는 곧바로 다음 학습 주제인 **이벤트 주도 아키텍처** 및 **일관성 보완책**으로 이어집니다. 또한 CQRS를 계기로, *“모든 시스템이 굳이 이 정도 복잡성을 필요로 하는가?”*라는 **비판적 시각**도 얻습니다. 자연스레 “이런 패턴은 언제 쓰는가?”를 고민하면서, 도구를 맹신하지 않고 합목적적으로 쓰는 법을 배우게 됩니다.
    

**6. 비동기와 탈결합 – 이벤트 주도 아키텍처와 메시징 배우기**

- **핵심 지식**: **Event-Driven Architecture (EDA)**의 원리, **도메인 이벤트**의 정의와 사용법, **발행-구독 모델**, 메시지 브로커의 역할, EDA의 장점 (느슨한 결합, 확장성)과 단점 (복잡한 흐름, 일관성 지연).
    
- **선행 이유**: 이벤트 주도 아키텍처는 REST와 함께 현대 시스템 통합의 양대 산맥입니다. REST가 동기 HTTP 기반이라면, EDA는 비동기 메시지 기반입니다. 학습자는 REST를 이해한 상태에서, EDA를 배워 _“동기 vs 비동기”_ 통신의 차이를 파악하게 됩니다. 또한 CQRS에서 느꼈던 eventual consistency 문제가 EDA에서는 상시 나타난다는 점, 그리고 이를 관리하는 기법이 필요함을 인식합니다. DIP, 헥사고날을 배운 상태에서 EDA를 보면, 자연히 **이벤트를 하나의 어댑터로 생각**할 수 있고, EDA 그림을 그릴 때 각 시스템이 헥사고날로 표현되며 이벤트가 출력-입력 포트를 잇는 모습이 떠오르므로 이해가 쉽습니다.
    
- **시야와 지식 확장**: EDA를 배우면 **소프트웨어 아키텍처의 시간 축**을 관리하는 법을 익힙니다. 지금까지는 요청-응답의 즉각성에 익숙했지만, EDA에서는 _일이 나중에 일어나도 된다_는 유연함을 받아들이게 됩니다. 이는 사고방식의 큰 전환이며, 학습자는 **“결과적 일관성”**이라는 현실과 조우합니다. 또한 EDA를 통해 **Cross-Context 통합**의 새로운 방식(중앙 이벤트 버스)을 이해함으로써, 조직 구조(팀별 서비스 분리)와 이벤트의 관계, **이벤트 스토밍** 같은 DDD 기법의 중요성도 깨닫게 됩니다. EDA 개념 습득 후, 학습자는 “A 서비스와 B 서비스가 데이터를 주고받아야 할 때, 반드시 API 호출이 아니라 B가 A의 이벤트를 구독하면 되겠군” 같은 **설계 아이디어의 확장**을 하게 됩니다. 즉, 문제 해결 옵션으로 **동기 호출 vs 비동기 이벤트** 두 카드를 모두 쓸 수 있는 레벨이 됩니다. 이 시점에서, **CAP 이론**(Consistency-Availability-Partition Tolerance의 트레이드오프) 같은 분산 시스템 이론에 대해서도 자연히 호기심이 생길 수 있습니다.
    

**7. 통합 패턴 심화 – 파이프&필터와 Saga(장기 실행 프로세스) 학습**

- **핵심 지식**: **파이프-필터 패턴**의 개념과 메시징에의 적용, **Saga 패턴(분산 트랜잭션 프로세스 관리)**의 개념과 구현방식 (오케스트레이션 vs 코레오그래피), Saga에서의 보상 트랜잭션 원리.
    
- **선행 이유**: 파이프-필터와 Saga는 모두 **이벤트 주도/비동기 시스템의 부가 패턴**입니다. EDA를 이해한 후, 그 환경에서 활용되는 대표적 패턴들을 배우면 지식이 견고해집니다. 특히 Saga는 분산 시스템에서 **데이터 일관성 회복** 방법으로 CQRS/EDA와 밀접히 연관되어 있으므로, 그 둘을 이해한 후 바로 배우는 게 좋습니다.
    
- **시야와 지식 확장**: 파이프-필터를 배우면 학습자는 **메시지 처리의 모듈화**에 눈뜨게 됩니다. 복잡한 이벤트 흐름을 단순한 단계들의 조합으로 분해하는 사고는, 다른 문제에도 응용되는 **추상화 기법**입니다. Saga를 배우면, 드디어 **분산 시스템에서 ACID를 어떻게 대체하는가**라는 큰 그림이 완성됩니다. *“여러 시스템에 걸친 트랜잭션을 이렇게 논리적으로 관리할 수 있구나”*를 이해하면, 학습자는 **대규모 시스템의 신뢰성**을 지탱하는 원리를 얻습니다. 또한 Saga의 보상 개념은 **논리적 반전(inversion)** 개념이어서, 이전에 DIP에서 접한 “추상화로 반전”과 개념적으로 통하는 면이 있습니다. DIP는 의존 방향 반전, Saga 보상은 행동의 반전이니까요. 이런 **메타 관점**에서 통찰도 가능해집니다. 이 단계까지 오면 학습자는 분산 환경에서 _데이터 정합성, 프로세스 완결성_을 지키는 기술들을 한 흐름으로 이해하고, **대규모 분산 아키텍처 그림**을 논리적으로 그릴 수 있게 됩니다.
    

**8. 사건을 기록하는 시스템 – 이벤트 소싱(Event Sourcing) 학습**

- **핵심 지식**: **이벤트 소싱**의 원리와 구현: 이벤트 스토어, 스냅샷, Aggregate 재구성, ORM과의 차이, 이벤트 소싱의 장점 (이력 감사, 시간 여행 디버깅, 성능)과 단점 (쿼리 어려움, 복잡성 증가). CQRS와 이벤트 소싱의 밀접한 관계도 포함.
    
- **선행 이유**: 이벤트 소싱은 DDD 구현 기술 중 가장 **진보적**이고 **어려운** 축에 듭니다. 이미 도메인 이벤트, CQRS, EDA 등을 맛본 후여야, 이벤트 소싱의 *“사건으로 상태를 표현한다”*는 개념이 쉽게 와닿습니다. 특히 CQRS와 세트로 이해되므로, CQRS를 확실히 소화한 다음 이걸 배우는 순서가 타당합니다.
    
- **시야와 지식 확장**: 이벤트 소싱을 배우면, 학습자는 **데이터를 바라보는 새로운 관점**을 습득합니다. 정적 상태 중심에서 **동적 변화 중심**으로 관점 전환이 일어납니다. 이는 **비판적 사고**에도 좋습니다. 예컨대 기존 DB 설계만 아는 사람은 “왜 굳이 그렇게 복잡하게” 생각하지만, 이벤트 소싱 개념을 알면 *“변경 이력은 언젠가 반드시 문제를 일으킨다 – 그래서 처음부터 저장하자”*라는 **근본적 설계 철학**을 이해합니다. 이로써, 학습자는 나중에 시스템 설계시 **Audit Logging**이나 **이벤트 발행 여부** 등을 통합적으로 고민할 수 있습니다. 또한 이벤트 소싱은 **함수형 프로그래밍적 사고**(불변 데이터, fold/reduce)와 통하는 부분이 있어서, 프로그래밍 패러다임에 대한 지평도 넓혀줄 수 있습니다. 이벤트 소싱을 끝으로 4장의 주요 기법들을 모두 학습하게 되면, 학습자는 **DDD 구현을 위한 “Full Stack” 지식을 논리적으로 체계화**하게 됩니다. 각 개념이 어떤 문제를 풀기 위해 등장했는지, 서로 어떻게 조합되는지 큰 그림이 머리에 그려지며, 이는 곧 **스스로 아키텍처를 설계**해볼 수 있는 능력으로 이어집니다.
    

**9. (선택) 분산 인프라 활용 – 데이터 그리드, 복제, Continuous Query 등 이해하기**

- **핵심 지식**: 데이터 그리드/패브릭의 개념 (메모리 분산 캐시), 데이터 복제 기법과 eventual consistency의 관계, Continuous Query/실시간 스트림 처리 개념, 분산처리(MapReduce 등) 활용 예.
    
- **선행 이유**: 이 부분은 특정 상황에서의 **첨단 구현 기법**들이므로, 반드시 모든 사람이 다 알아야 하는 건 아닙니다. 그러나 대규모 시스템 작업을 할 사람에게는 유용합니다. DDD의 핵심 개념과 주요 패턴들을 다 익힌 뒤, “성능 향상을 위해 인프라 레벨에서 어떤 옵션들이 있나”를 훑는 정도로 학습할 수 있습니다.
    
- **시야와 지식 확장**: 이를 학습하면, **기술적 최적화** 수단들을 알게 되어 아키텍처 선택지의 폭이 넓어집니다. 예컨대, “우리 시스템 조회가 너무 많은데 DB replication 읽기 전용 복제본을 둘까?” 또는 “전 세계 사용자 위해 다중 region 배포+데이터 복제를 해야겠다” 등의 판단이 가능해집니다. Continuous Query 같은 개념은 UI/UX 실시간화에도 연결되므로, **사용자 경험 개선과 백엔드 설계의 접점**을 이해하게 됩니다. 다만, 이 단계는 구체적 제품 (Kafka, Redis Streams, Spark 등) 학습으로 이어질 수 있으므로, **필요한 사람만 깊이 파고들도록** 선택 학습으로 둡니다.
    

**10. 아키텍처와 도메인의 균형 – 우선순위 재확인**

- **핵심 메시지**: “아키텍처는 중요하지만 **도메인 모델이 더 오래 가치 있다**”는 인사이트.
    
- **이유**: 4장의 끝맺음으로서, 다양한 기술과 패턴을 배웠지만, 학습자는 **다시 본질로 돌아와**야 합니다. 이 단계에서, 에반스의 DDD 철학 – _“핵심 도메인에 집중하라”_ –를 상기시키고, 아키텍처적 fancy함에 치우쳐 모델이 흐려지지 않게 해야 함을 강조합니다.
    
- **확장**: 학습자는 모든 테크닉을 배운 후 이 말을 들으면, 그 의미를 깊이 통찰하게 됩니다. _“아, 결국 기술은 바뀔 수 있어도 도메인 지식은 남는구나. 내가 DDD 하는 궁극 목적은 이 복잡한 비즈니스 지식을 잘 잡아내는 것이지, 기술 자랑이 아니구나.”_ 이러한 태도 변화는 향후 **의사결정의 기준**이 되어, 새로운 유행 기술 앞에서도 흔들리지 않고 도메인 가치를 따질 수 있는 엔지니어로 성장시키는 토대가 될 것입니다.
    

이상의 흐름을 따르면, 학습자는 챕터 순서에 의존하지 않고도 개념들을 **논리적 난이도 순**으로 익히고, 각 개념이 해결하는 **문제와 맥락**을 이해하며, **전반적인 DDD 적용 능력**을 키울 수 있을 것입니다. 단계 간 **메르바르도(Mermaid)** 다이어그램 등 시각화를 활용하면, 개념 연결이 더 명확해질 수 있습니다. 아래는 이러한 학습 흐름에서 소개된 주요 개념들의 관계를 요약한 도식입니다:

```mermaid
flowchart LR
    subgraph "도메인 격리 (기초)"
        Layered["계층 아키텍처"] --> DIP["DIP\n(의존성 역전)"]
    end
    subgraph "내부 구조 (대칭성)"
        DIP --> Hexagon["헥사고날\n(포트-어댑터)"]
        Hexagon --> Testing["테스트 용이성\n(인메모리 대체 등)"]
    end
    subgraph "경계 확장 (서비스화)"
        Hexagon --> SOA["서비스 지향\n(컨텍스트 경계)"]
        SOA --> REST["RESTful API\n(동기 통합)"]
        SOA --> Messaging["이벤트 메시징\n(비동기 통합)"]
    end
    subgraph "고급 패턴 (복잡성 대응)"
        Hexagon --> CQRS["CQRS\n(쓰기/읽기 분리)"]
        Messaging --> EDA["이벤트 주도\n아키텍처"]
        CQRS --> EventuallyConsistent["최종 일관성\n(지연 동기화)"]
        EDA --> Saga["Saga\n(장기 프로세스)"]
        EDA --> "Pipes & Filters\n(메시지 처리 흐름)"
        CQRS --> EventSourcing["이벤트 소싱\n(이력 저장)"]
        EventSourcing --> CQRS
        EDA --> EventSourcing
    end
    subgraph "분산 기술 (최적화)"
        EDA --> "데이터 복제\n(컨텍스트간/다중노드)"
        EDA --> "지속적 쿼리\n(실시간 갱신)"
        Saga --> "분산 처리\n(병렬 계산)"
    end
    Note["*도메인 모델이 핵심 (항상 우선)*"]:::noteStyle
    class Note noteStyle;
```

위 도식에서 좌측에서 우측으로 갈수록 고급 개념이며, 화살표는 “지식 선행/연관”을 나타냅니다. 예를 들어 DIP 없이는 Hexagon 이해가 어려우므로 DIP -> Hexagon, Hexagon 개념이 CQRS, EDA 등에도 이어져 쓰이므로 Hexagon -> CQRS, Hexagon -> SOA 등으로 표기했습니다. 이러한 **지식 맥락 지도**를 따라 학습하면, 개념들 간의 연결고리가 명확해지고, 학습자의 **인지 부하**가 줄어듭니다. 각 개념이 **논리적 필연성** 속에서 소개되므로, “왜 이걸 배워야 하지?”라는 의문이 자연히 해소됩니다.

## 2025년의 관점: 4장의 개념을 확장하는 지식 영역과 논리적 탐구 과제

2025년 현재, 소프트웨어 아키텍처와 DDD 분야는 더욱 발전하고 세분화되었습니다. 4장에서 다룬 개념들을 기반으로, **현재 시점에 주목하거나 탐구할 만한 지식 영역과 과제**를 마지막으로 제시합니다. 이는 논리적으로 4장의 내용을 **새로운 환경에 적용**하거나 **깊이 발전**시키는 방향들입니다:

1. **마이크로서비스 아키텍처의 최적화와 한계** – 4장의 서비스 지향 개념은 마이크로서비스 트렌드로 꽃피웠습니다. 2025년에는 **마이크로서비스의 난점** (예: 서비스간 트랜잭션, 분산 모니터링)과 **모노리스 회귀 논의**까지 나오고 있습니다. **탐구 과제**: _“어떻게 하면 바운디드 컨텍스트를 적절한 서비스로 구현하면서도, 분산 시스템의 복잡성을 완화할 수 있을까?”_ 논리적으로, **도메인 모델의 응집성과 배포 단위의 균형**을 다시 고민해야 합니다. 예컨대, **모듈러 모노리스**나 **셀룰러 아키텍처** 등이 대안으로 떠오르고 있는데, 이를 DDD와 접목해 연구해볼 수 있습니다. “서비스는 작게”라는 기존 명제에 반례 사례들이 나오면서, *“서비스 경계는 도메인 경계와 동일시하되, 너무 쪼개지 말라”*는 4장의 조언이 재조명되고 있습니다.
    
2. **이벤트 주도 마이크로서비스와 카프카(Kafka) 등 이벤트 스트림 플랫폼 활용** – 4장의 EDA 개념은 현대 데이터 스트림 처리 플랫폼과 결합되어 **기업 전반의 이벤트 주도 설계**로 발전했습니다. Kafka, Pulsar 등의 **이벤트 스트리밍 플랫폼**은 단순 브로커 이상의 **데이터 로그**로 쓰이며, **Event Sourcing + CQRS + EDA**를 통합적으로 구현하게 합니다. **탐구 과제**: _“대규모 이벤트 스트림에서 도메인 이벤트를 관리하는 최선의 방법은? 각 서비스의 경계를 침범하지 않으면서 전사적(event-driven) 아키텍처를 설계하려면?”_ 여기서 논리적으로 다뤄야 할 것은 **이벤트 평형**입니다. 이벤트 남발로 서비스 경계가 흐려지지 않도록, **퍼블리시/구독 규약**과 **이벤트 모델링 기법(Event Storming)**이 중요합니다. 2025년에는 **Event Modeling**이라는 방법론도 대두되어, 이벤트 흐름을 하나의 **논리적 모델**로 다루고 있습니다. DDD와 함께 이를 적용하는 연구가 활발합니다.
    
3. **사가 패턴의 공식화와 보편화** – Saga는 이제 마이크로서비스 필수 개념으로 자리잡았습니다. 2025년에는 **Saga Orchestrator를 위한 프레임워크**(예: Camunda, Temporal.io)들이 발전하여, 선언적으로 Saga를 정의하게 돕습니다. 또한 **보상 트랜잭션의 설계 패턴**이 축적되어 있습니다. **탐구 과제**: _“Saga를 이용해 데이터 일관성을 공식적으로 검증하거나 보장할 수 있을까?”_ 이는 **형식 논리(temporal logic)**와 연계됩니다. 예를 들어 TLA+ 같은 형식 명세로 Saga 절차를 모델링하고, **안전 속성** (예: “중복으로 처리되지 않는다”, “모든 보상은 그 이전 단계 효과를 정확히 상쇄한다”)을 증명하려는 시도가 가능합니다. DDD 관점에서는 Saga의 단계들이 각각 도메인 이벤트로 표현될 수 있으므로, **이벤트 상호작용의 논리 검증**이라는 새로운 연구 주제가 됩니다. 실제 현업에서도 Saga 설계 미스로 인한 데이터 정합성 버그가 흔하기에, 이를 방지하는 **도구나 방법론 연구**가 가치 있습니다.
    
4. **분산 시스템에서의 도메인 모델 불변식 보장** – 4장의 여러 패턴들이 결국 **분산 환경에서 불변식을 어떻게 유지할 것인가**와 연결됩니다. 2025년에는 **CRDT(Conflict-free Replicated Data Type)**나 **Eventual Consistency Models**에 대한 이론과 구현이 많습니다. **탐구 과제**: _“분산된 애그리게잇들을 CRDT로 모델링할 수 있을까? DDD의 애그리게잇 불변식을 CRDT의 수학적 특성으로 증명할 수 있을까?”_ 이는 **수리논리 및 추상대수**와 DDD의 만남입니다. 예를 들어 재고 수량 같은 값은 증감 동작에 대해 교환 법칙이 성립하므로 (10 증가 후 5 감소 = 5 감소 후 10 증가), CRDT로 안전히 복제 가능하지만, 주문 승인 같은 이벤트는 비교적 선후 의존성이 있어 어렵습니다. 이런 맥락에서 **어떤 도메인 이벤트들이 교환/결합적 속성을 가지며 분산처리 안전한가**를 연구하는 것도 논리적으로 흥미롭습니다. 이는 **CAP 이론의 실제 적용과 도메인 요구**를 연결짓는 연구가 될 수 있습니다.
    
5. **클라우드-네이티브 아키텍처와 DDD** – 클라우드 환경에서는 **서버리스(Serverless)**, **분산 메시지 큐**, **NoSQL** 등이 일반화되었습니다. 4장의 개념들을 클라우드 문맥에서 확장해보면, 예컨대 **Serverless Function**을 헥사고날 어댑터로 보는 접근, NoSQL (Event Store, DynamoDB 등)에서 이벤트 소싱 구현 전략 등이 있습니다. **탐구 과제**: _“서버리스 환경에서 DDD 패턴들을 적용하려면, 상태 없는 함수를 어떻게 조합하여 도메인 상태를 관리할 것인가?”_ 논리적으로, 서버리스 함수는 짧은 실행과 상태 저장을 외부화한다는 특징이 있어, **도메인 객체의 수명** 개념과 어긋납니다. 이 갭을 메우기 위해 **세션 상태**나 **분산 캐시**를 써야 하는데, 이러한 부분을 추상화해 개발자 경험을 개선하는 것이 과제입니다. 가령, **Orleans 프레임워크**는 가상 Actor 모델로 각 도메인 개체를 1:1로 Actor화하여 분산 환경에서도 마치 OOP처럼 코딩하게 합니다. 이것은 DDD Aggregate와 궁합이 좋습니다. 2025년엔 Orleans, Akka.NET 등 Actor 모델 기술과 DDD의 결합 사례가 늘었으니, **“Actor = Aggregate”**라는 관점에서 **일관성 확보 (한 액터=한 스레드)**를 논리적으로 분석하고 활용하는 연구가 의미있습니다.
    
6. **AI와 DDD의 만남 – 지능형 도메인 모델** – 최신 트렌드로 AI/ML이 있지만, 이것을 DDD와 직접 엮는 건 초기 단계입니다. 그러나 한 가지 각도는 **“DDD 모델에서 생성된 이벤트나 데이터로 ML을 한다”**입니다. 예를 들어 이벤트 소싱으로 쌓인 이벤트 로그는 ML에게 **양질의 학습 데이터**가 될 수 있습니다. **탐구 과제**: _“도메인 이벤트 스트림에서 패턴을 학습해 비즈니스 의사결정을 돕는 방법은?”_ 또는 _“유저 행동 이벤트를 실시간 분석해 다음 액션을 추천하는 시스템을 DDD 패턴으로 구현하면 어떻게 될까?”_ 등이 있습니다. 논리적으로, DDD의 이벤트는 **형식 언어**로 정의된 사실들이고, ML은 통계적 패턴을 다루므로, 둘을 연결하려면 **추론 규칙**을 학습하는 **연합논리**가 필요할 수 있습니다. 이건 아직 열린 연구지만, DDD 이벤트를 **지식 그래프**로 축적하고, 거기에 **논리 추론+기계학습**을 접목하는 시도 등이 2025년 연구 주제로 거론됩니다.
    
7. **Formal DDD – 형식 기법을 통한 모델 검증** – 논리학적 관점에서 볼 때, DDD의 개념들을 **형식적으로 검증**하는 시도는 매우 흥미롭지만 드문 편입니다. **탐구 과제**: _“애그리게잇의 불변식을 일종의 논리 명제로 표현하고, 코드나 설계가 그것을 항상 만족함을 보증할 수 있을까?”_ 예를 들어 Alloy 같은 도구로 애그리게잇 상태 전이 모델을 만들어 **모델 체크**를 해볼 수 있습니다. 혹은 이벤트 소싱 시스템의 이벤트 적용 순서를 TLA+로 모델링해 안전/활성 속성을 증명하는 방법도 있습니다. 4장에서 이야기한 각 패턴 – 예: DIP는 **의존성 그래프가 DAG임**을 뜻하는 논리 조건, CQRS는 **한 모델에 조회 연산 없음**이라는 정량 명제 등 – 을 형식언어로 정의하고, 시스템 아키텍처를 검증하는 툴로 활용할 수 있습니다. 2025년엔 아직 상용화되진 않았지만, **“증명 가능한 소프트웨어 아키텍처”**라는 개념이 부상 중입니다. DDD는 **높은 수준 설계**이므로 검증 루틴을 짜기 까다롭지만, 제한된 범위에서 시작해볼 수 있는 미래 연구 과제입니다.
    

**결론적으로**, 4장에서 다룬 철학과 패턴들은 2025년 현재도 여전히 유효하면서, 새로운 도전들과 조합되어 진화하고 있습니다. 핵심은 변하지 않았습니다: **도메인 지식의 본질**을 소프트웨어에 담아내고 지키는 일입니다. 오늘날의 아키텍처 결정들 – monolith vs microservices, synchronous vs asynchronous, SQL vs NoSQL, cloud vs on-prem 등 – 어느 것을 취하든, 그 **논리적 평가 기준은 “도메인 모델을 얼마나 잘 보호하고 표현하느냐”**가 되어야 함을 잊지 말아야 합니다. 미래의 기술 스택이 바뀌어도, 이 **우선순위 원칙**이 논리적 나침반이 되어준다면, 우리는 DDD와 아키텍처 설계에서 흔들리지 않고 올바른 길을 찾아갈 수 있을 것입니다.